---
description: 
globs: 
alwaysApply: false
---
Jesteś doświadczonym inżynierem QA, którego zadaniem jest stworzenie kompleksowego planu testów dla projektu programistycznego. Przeanalizuj poniższe informacje o projekcie:

<kod_projektu>
(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: src/env.d.ts
================================================
/// <reference types="astro/client" />

import type { SupabaseClient } from "@supabase/supabase-js";
import type { Database } from "./db/database.types.ts";

declare global {
  namespace App {
    interface Locals {
      supabase: SupabaseClient<Database>;
      user?: {
        id: string;
        email?: string;
      };
    }
  }
}

interface ImportMetaEnv {
  // Server-side only
  readonly SUPABASE_URL: string;
  readonly SUPABASE_KEY: string;

  // Client-side (browser) - exposed with PUBLIC_ prefix
  readonly PUBLIC_SUPABASE_URL: string;
  readonly PUBLIC_SUPABASE_KEY: string;

  // AI Provider Configuration
  // Use "mock" for development without API costs
  readonly AI_PROVIDER: "openrouter" | "google" | "mock";
  readonly OPENROUTER_API_KEY?: string;
  readonly GOOGLE_API_KEY?: string;
  readonly AI_MODEL?: string;
  readonly AI_TIMEOUT_MS?: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}



================================================
FILE: src/types.ts
================================================
import type { Database, Tables, TablesInsert, TablesUpdate } from "./db/database.types";

// ============================================================================
// Core Domain Types
// ============================================================================

/**
 * Recipe Schema (schema_v1)
 * This is the JSONB structure stored in the recipes.recipe column
 */
export interface RecipeSchema {
  title: string;
  summary?: string;
  description?: string;
  prep_time_minutes: number;
  cook_time_minutes: number;
  servings: number;
  difficulty: "easy" | "medium" | "hard";
  cuisine?: string;
  ingredients: string[];
  instructions: string[];
  tags?: string[];
  dietary_info?: {
    vegetarian?: boolean;
    vegan?: boolean;
    gluten_free?: boolean;
    dairy_free?: boolean;
    nut_free?: boolean;
    [key: string]: boolean | undefined;
  };
  nutrition?: {
    calories?: number;
    protein_g?: number;
    carbs_g?: number;
    fat_g?: number;
    [key: string]: number | undefined;
  };
}

/**
 * Diet type enum - must match database CHECK constraint
 */
export type DietType =
  | "vegan"
  | "vegetarian"
  | "pescatarian"
  | "keto"
  | "paleo"
  | "gluten_free"
  | "dairy_free"
  | "low_carb"
  | "mediterranean"
  | "omnivore";

/**
 * Event type enum - must match database CHECK constraint
 */
export type EventType = "session_start" | "profile_edited" | "ai_prompt_sent" | "ai_recipe_generated" | "recipe_saved";

/**
 * Recipe difficulty level
 */
export type RecipeDifficulty = "easy" | "medium" | "hard";

/**
 * Recipe sort order for list queries
 */
export type RecipeSortOrder = "recent" | "oldest";

// ============================================================================
// Profile DTOs
// ============================================================================

/**
 * Profile DTO - returned from GET /api/profile
 * Direct mapping from profiles table Row
 */
export type ProfileDTO = Tables<"profiles">;

/**
 * Create Profile Command - body for POST /api/profile
 * All fields optional as user can provide any combination
 * Server manages user_id, created_at, updated_at
 */
export type CreateProfileCommand = Omit<TablesInsert<"profiles">, "user_id" | "created_at" | "updated_at">;

/**
 * Update Profile Command - body for PUT /api/profile
 * All fields optional for partial updates
 * Server manages user_id and timestamps
 */
export type UpdateProfileCommand = Omit<TablesUpdate<"profiles">, "user_id" | "created_at" | "updated_at">;

// ============================================================================
// Recipe DTOs
// ============================================================================

/**
 * Generate Recipe Command - body for POST /api/recipes/generate
 * User prompt for AI recipe generation
 */
export interface GenerateRecipeCommand {
  prompt: string;
}

/**
 * Generate Recipe Response - response from POST /api/recipes/generate
 * Contains generated recipe and metadata
 */
export interface GenerateRecipeResponse {
  recipe: RecipeSchema;
  generation_id: string;
  generated_at: string;
}

/**
 * Save Recipe Command - body for POST /api/recipes
 * User submits recipe with optional tags
 * Server manages id, user_id, derived fields, and timestamps
 */
export interface SaveRecipeCommand {
  recipe: RecipeSchema;
  tags?: string[];
}

/**
 * Recipe Summary DTO - returned from POST /api/recipes
 * Lightweight summary after successful save
 */
export type RecipeSummaryDTO = Pick<
  Tables<"recipes">,
  "id" | "user_id" | "title" | "summary" | "tags" | "created_at" | "updated_at"
>;

/**
 * Recipe List Item DTO - individual item in GET /api/recipes response
 * Minimal data for list display (no full recipe JSONB)
 */
export type RecipeListItemDTO = Pick<Tables<"recipes">, "id" | "title" | "summary" | "tags" | "created_at">;

/**
 * Recipe Details DTO - returned from GET /api/recipes/:id
 * Complete recipe data including full JSONB
 * Excludes internal database fields (search_tsv, ingredients_text)
 */
export type RecipeDetailsDTO = Omit<Tables<"recipes">, "search_tsv" | "ingredients_text">;

/**
 * Recipe Query Params - query parameters for GET /api/recipes
 * Used for search, filtering, sorting, and pagination
 */
export interface RecipeQueryParams {
  search?: string;
  tags?: string; // Comma-separated tag list for OR filtering
  sort?: RecipeSortOrder;
  limit?: number;
  cursor?: string; // Base64 encoded (created_at:id) for keyset pagination
  offset?: number; // Alternative to cursor for simple pagination
}

/**
 * Pagination metadata included in list responses
 */
export interface PaginationMeta {
  limit: number;
  next_cursor: string | null;
  has_more: boolean;
  total_count: number;
}

/**
 * Recipe List Response - response from GET /api/recipes
 * Container for paginated recipe list
 */
export interface RecipeListResponse {
  data: RecipeListItemDTO[];
  pagination: PaginationMeta;
  message?: string; // Optional message for empty states
}

// ============================================================================
// Event DTOs
// ============================================================================

/**
 * Create Event Command - body for POST /api/events
 * User can explicitly log events (primarily session_start)
 * Server manages id, user_id, occurred_at
 */
export interface CreateEventCommand {
  type: EventType;
  payload?: Database["public"]["Tables"]["events"]["Row"]["payload"];
}

/**
 * Event DTO - returned from POST /api/events
 * Direct mapping from events table Row
 */
export type EventDTO = Tables<"events">;

// ============================================================================
// Auth DTOs
// ============================================================================

/**
 * Register Command - body for POST /auth/v1/signup
 */
export interface RegisterCommand {
  email: string;
  password: string;
}

/**
 * Login Command - body for POST /auth/v1/token
 * Same structure as RegisterCommand
 */
export type LoginCommand = RegisterCommand;

/**
 * Auth Response - response from Supabase Auth endpoints
 * Returned on successful registration/login
 */
export interface AuthResponse {
  access_token: string;
  token_type: string;
  expires_in: number;
  refresh_token: string;
  user: {
    id: string;
    email: string;
    created_at: string;
  };
}

// ============================================================================
// Error DTOs
// ============================================================================

/**
 * Standard API Error Response
 * All error responses follow this format
 */
export interface ApiError {
  error: string;
  message: string;
  details?: Record<string, unknown>;
  request_id?: string;
}

/**
 * Validation Error Details
 * Used in ApiError.details for 400 Bad Request responses
 */
export type ValidationErrorDetails = Record<string, string | string[]>;

// ============================================================================
// RPC Function Types
// ============================================================================

/**
 * Arguments for insert_recipe_safe RPC function
 * Server-side validation against disliked ingredients
 */
export interface InsertRecipeSafeArgs {
  p_recipe: RecipeSchema;
  p_tags?: string[];
}

/**
 * Arguments for export_events_ndjson RPC function
 * Service role only - for analytics export
 */
export interface ExportEventsNdjsonArgs {
  p_from_date?: string;
  p_to_date?: string;
}

// ============================================================================
// Utility Types
// ============================================================================

/**
 * Type guard to check if value is a valid EventType
 */
export function isEventType(value: string): value is EventType {
  return ["session_start", "profile_edited", "ai_prompt_sent", "ai_recipe_generated", "recipe_saved"].includes(value);
}

/**
 * Type guard to check if value is a valid DietType
 */
export function isDietType(value: string): value is DietType {
  return [
    "vegan",
    "vegetarian",
    "pescatarian",
    "keto",
    "paleo",
    "gluten_free",
    "dairy_free",
    "low_carb",
    "mediterranean",
    "omnivore",
  ].includes(value);
}

/**
 * Type guard to check if value is a valid RecipeDifficulty
 */
export function isRecipeDifficulty(value: string): value is RecipeDifficulty {
  return ["easy", "medium", "hard"].includes(value);
}

// ============================================================================
// Frontend ViewModel Types
// ============================================================================

/**
 * List Filters View Model
 * Represents the current state of filters in the recipe list
 * Synchronized with URL search params
 */
export interface ListFiltersVM {
  search?: string;
  tags: string[];
  sort: RecipeSortOrder;
  limit: number;
  offset?: number;
  cursor?: string | null;
}

/**
 * Generator Draft View Model
 * Represents the state of the recipe generator panel
 * Persisted in sessionStorage
 */
export interface GeneratorDraftVM {
  prompt: string;
  recipe?: RecipeSchema;
  generationId?: string;
  generatedAt?: string;
}

/**
 * Recipe Card View Model
 * Alias for RecipeListItemDTO - used in list display
 */
export type RecipeCardVM = RecipeListItemDTO;

/**
 * Preview Panel Mode
 * Determines whether showing a draft (from generator) or saved recipe
 */
export type PreviewMode = "draft" | "saved";

/**
 * UI Error
 * Frontend-friendly error type mapped from ApiError
 * Includes standardized error codes and user-friendly messages
 */
export interface UiError {
  code: 400 | 401 | 404 | 413 | 429 | 500 | 503;
  message: string;
  details?: Record<string, unknown>;
}



================================================
FILE: src/components/AppShell.tsx
================================================
import { ThemeProvider } from "./theme/ThemeProvider";
import { Header } from "./Header";

/**
 * AppShell Component
 *
 * Renders Header with ThemeProvider context.
 * Used as a separate React island for header functionality.
 *
 * @component
 */
export function AppShell() {
  return (
    <ThemeProvider>
      <Header />
    </ThemeProvider>
  );
}



================================================
FILE: src/components/Header.tsx
================================================
import { DarkModeToggle } from "./theme/DarkModeToggle";
import { Button } from "./ui/button";
import { UserMenu } from "./auth/UserMenu";
import { useAuth } from "../lib/auth/useAuth";
import { BookOpen, Sparkles } from "lucide-react";

/**
 * Header Component
 *
 * Main application header with logo, navigation, and user controls.
 *
 * Features:
 * - Logo/brand
 * - Navigation links (Recipes, Generator)
 * - Dark mode toggle
 * - User menu with profile and logout (when authenticated)
 * - Sign in link (when not authenticated)
 * - Responsive design with proper spacing
 *
 * @component
 */
export function Header() {
  const { user, loading } = useAuth();

  return (
    <header className="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
      <div className="container flex h-14 items-center px-4">
        {/* Logo/Brand */}
        <div className="mr-6 flex">
          <a href="/" className="flex items-center space-x-2">
            <span className="text-xl font-bold">SavorAI</span>
          </a>
        </div>

        {/* Main Navigation - visible when authenticated */}
        {user && !loading && (
          <nav className="hidden md:flex items-center space-x-1 mr-4">
            <Button variant="ghost" size="sm" asChild>
              <a href="/app" className="flex items-center gap-2">
                <BookOpen className="h-4 w-4" />
                Recipes
              </a>
            </Button>
            <Button variant="ghost" size="sm" asChild>
              <a href="/app#generator" className="flex items-center gap-2">
                <Sparkles className="h-4 w-4" />
                Generator
              </a>
            </Button>
          </nav>
        )}

        {/* Spacer */}
        <div className="flex flex-1 items-center justify-end space-x-3">
          {/* Dark Mode Toggle */}
          <DarkModeToggle />

          {/* Language Switch - Placeholder for Phase 2 */}
          {/* <LanguageSwitch /> */}

          {/* User Info / Auth */}
          {!loading && (
            <>
              {user ? (
                // Show user menu when authenticated
                <UserMenu email={user.email ?? "User"} />
              ) : (
                // Show sign in link when not authenticated
                <Button variant="ghost" size="sm" asChild>
                  <a href="/login">Sign In</a>
                </Button>
              )}
            </>
          )}
        </div>
      </div>
    </header>
  );
}



================================================
FILE: src/components/LoginThemeToggle.tsx
================================================
import { ThemeProvider } from "./theme/ThemeProvider";
import { DarkModeToggle } from "./theme/DarkModeToggle";

/**
 * LoginThemeToggle Component
 *
 * Wrapper that provides ThemeProvider context for DarkModeToggle
 * on the login page. Needed because Astro islands don't share context.
 *
 * @component
 */
export function LoginThemeToggle() {
  return (
    <ThemeProvider>
      <div className="fixed top-4 right-4 z-50">
        <DarkModeToggle />
      </div>
    </ThemeProvider>
  );
}



================================================
FILE: src/components/ProfileForm.tsx
================================================
import { useState, useEffect, useRef } from "react";
import { Button } from "./ui/button";
import { Label } from "./ui/label";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "./ui/card";
import { DietTypeSelect } from "./profile/DietTypeSelect";
import { TagsInput } from "./profile/TagsInput";
import {
  normalizeStringArray,
  hasAtLeastOneField,
  isFormDirty,
  type ProfileFormValues,
  type ProfileOperation,
} from "../lib/mappers/profile";
import type { DietType } from "../types";

interface ProfileFormProps {
  /** Initial form values (from server or empty) */
  initialValues: ProfileFormValues;
  /** Form mode - create or update */
  mode: ProfileOperation;
  /** Submit handler - called with validated form values */
  onSubmit: (values: ProfileFormValues) => Promise<void>;
}

/**
 * ProfileForm Component
 *
 * Controlled form for editing dietary preferences profile.
 * Includes three fields: dietType, dislikedIngredients, preferredCuisines.
 *
 * Features:
 * - Client-side validation (≥1 field required, max 100 items, max 50 chars per item)
 * - Auto-normalization (lowercase, trim, dedupe)
 * - Dirty checking (disable save if no changes in update mode)
 * - Focus management (focuses first error field on validation failure)
 * - Full ARIA support for screen readers
 * - Inline error messages with role="alert"
 *
 * @component
 */
export function ProfileForm({ initialValues, mode, onSubmit }: ProfileFormProps) {
  const [values, setValues] = useState<ProfileFormValues>(initialValues);
  const [errors, setErrors] = useState<Partial<Record<keyof ProfileFormValues, string>>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Refs for focus management
  const dietTypeRef = useRef<HTMLButtonElement>(null);
  const dislikedIngredientsRef = useRef<HTMLInputElement>(null);
  const preferredCuisinesRef = useRef<HTMLInputElement>(null);
  const formRef = useRef<HTMLFormElement>(null);

  // Update form values when initialValues change
  useEffect(() => {
    setValues(initialValues);
  }, [initialValues]);

  // Validate form
  const validate = (): boolean => {
    const newErrors: Partial<Record<keyof ProfileFormValues, string>> = {};

    // Check if at least one field is filled
    if (!hasAtLeastOneField(values)) {
      newErrors.dietType = "At least one field must be filled";
      setErrors(newErrors);
      return false;
    }

    // Validate disliked ingredients
    if (values.dislikedIngredients.length > 100) {
      newErrors.dislikedIngredients = "Maximum 100 ingredients allowed";
    }

    for (const ingredient of values.dislikedIngredients) {
      if (ingredient.length > 50) {
        newErrors.dislikedIngredients = "Each ingredient must be 50 characters or less";
        break;
      }
    }

    // Validate preferred cuisines
    if (values.preferredCuisines.length > 100) {
      newErrors.preferredCuisines = "Maximum 100 cuisines allowed";
    }

    for (const cuisine of values.preferredCuisines) {
      if (cuisine.length > 50) {
        newErrors.preferredCuisines = "Each cuisine must be 50 characters or less";
        break;
      }
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Handle form submission
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!validate()) {
      // Focus on first field with error
      if (errors.dietType) {
        dietTypeRef.current?.focus();
      } else if (errors.dislikedIngredients) {
        dislikedIngredientsRef.current?.focus();
      } else if (errors.preferredCuisines) {
        preferredCuisinesRef.current?.focus();
      }
      return;
    }

    setIsSubmitting(true);
    try {
      await onSubmit(values);
    } finally {
      setIsSubmitting(false);
    }
  };

  // Handle field changes
  const handleDietTypeChange = (dietType: DietType | null) => {
    setValues((prev) => ({ ...prev, dietType }));
    setErrors((prev) => ({ ...prev, dietType: undefined }));
  };

  const handleDislikedIngredientsChange = (ingredients: string[]) => {
    const normalized = normalizeStringArray(ingredients);
    setValues((prev) => ({ ...prev, dislikedIngredients: normalized }));
    setErrors((prev) => ({ ...prev, dislikedIngredients: undefined }));
  };

  const handlePreferredCuisinesChange = (cuisines: string[]) => {
    const normalized = normalizeStringArray(cuisines);
    setValues((prev) => ({ ...prev, preferredCuisines: normalized }));
    setErrors((prev) => ({ ...prev, preferredCuisines: undefined }));
  };

  // Check if form is valid and dirty
  const isDirty = isFormDirty(values, initialValues);
  const isValid = hasAtLeastOneField(values);
  const canSubmit = isValid && (mode === "create" || isDirty) && !isSubmitting;

  return (
    <form onSubmit={handleSubmit} ref={formRef} aria-label="Profile preferences form">
      <Card>
        <CardHeader>
          <CardTitle>{mode === "create" ? "Create Profile" : "Edit Profile"}</CardTitle>
          <CardDescription>
            {mode === "create"
              ? "Set up your dietary preferences to get started."
              : "Update your dietary preferences to refine your recommendations."}
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          {/* Diet Type */}
          <div className="space-y-2">
            <Label htmlFor="dietType">Diet Type (Optional)</Label>
            <DietTypeSelect
              value={values.dietType}
              onChange={handleDietTypeChange}
              ref={dietTypeRef}
              aria-invalid={!!errors.dietType}
              aria-describedby={errors.dietType ? "dietType-error" : "dietType-helper"}
            />
            {errors.dietType && (
              <p id="dietType-error" className="text-sm text-destructive" role="alert">
                {errors.dietType}
              </p>
            )}
            <p id="dietType-helper" className="text-sm text-muted-foreground">
              Select your dietary preference to filter recipes accordingly.
            </p>
          </div>

          {/* Disliked Ingredients */}
          <div className="space-y-2">
            <Label htmlFor="dislikedIngredients">Disliked Ingredients (Optional)</Label>
            <TagsInput
              name="dislikedIngredients"
              value={values.dislikedIngredients}
              onChange={handleDislikedIngredientsChange}
              placeholder="Add ingredients you want to avoid..."
              ref={dislikedIngredientsRef}
              aria-invalid={!!errors.dislikedIngredients}
              aria-describedby={errors.dislikedIngredients ? "dislikedIngredients-error" : "dislikedIngredients-helper"}
            />
            {errors.dislikedIngredients && (
              <p id="dislikedIngredients-error" className="text-sm text-destructive" role="alert">
                {errors.dislikedIngredients}
              </p>
            )}
            <p id="dislikedIngredients-helper" className="text-sm text-muted-foreground">
              Recipes containing these ingredients will be blocked from saving.
            </p>
          </div>

          {/* Preferred Cuisines */}
          <div className="space-y-2">
            <Label htmlFor="preferredCuisines">Preferred Cuisines (Optional)</Label>
            <TagsInput
              name="preferredCuisines"
              value={values.preferredCuisines}
              onChange={handlePreferredCuisinesChange}
              placeholder="Add cuisines you enjoy..."
              ref={preferredCuisinesRef}
              aria-invalid={!!errors.preferredCuisines}
              aria-describedby={errors.preferredCuisines ? "preferredCuisines-error" : "preferredCuisines-helper"}
            />
            {errors.preferredCuisines && (
              <p id="preferredCuisines-error" className="text-sm text-destructive" role="alert">
                {errors.preferredCuisines}
              </p>
            )}
            <p id="preferredCuisines-helper" className="text-sm text-muted-foreground">
              We'll prioritize recipes from these cuisines in your recommendations.
            </p>
          </div>

          {/* General validation error */}
          {!isValid && (
            <div className="text-sm text-destructive" role="alert" aria-live="polite">
              Please fill in at least one field to save your profile.
            </div>
          )}

          {/* Submit Button */}
          <Button
            type="submit"
            disabled={!canSubmit}
            className="w-full"
            aria-label={isSubmitting ? "Saving profile" : mode === "create" ? "Create profile" : "Save changes to profile"}
          >
            {isSubmitting ? "Saving..." : mode === "create" ? "Create Profile" : "Save Changes"}
          </Button>
        </CardContent>
      </Card>
    </form>
  );
}



================================================
FILE: src/components/ProfilePage.tsx
================================================
import QueryProvider from "./QueryProvider";
import ProfileView from "./ProfileView";
import { Toaster } from "./ui/sonner";

/**
 * ProfilePage Component
 *
 * Client-side only wrapper for the profile view.
 * Combines QueryProvider, ProfileView, and Toaster into a single island.
 *
 * @component
 */
export default function ProfilePage() {
  return (
    <QueryProvider>
      <ProfileView />
      <Toaster />
    </QueryProvider>
  );
}



================================================
FILE: src/components/ProfileView.tsx
================================================
import { useState } from "react";
import { toast } from "sonner";
import { useProfileQuery, useCreateProfileMutation, useUpdateProfileMutation } from "../lib/api/profile";
import {
  profileDtoToFormValues,
  emptyProfileFormValues,
  formValuesToCreateCommand,
  formValuesToUpdateCommand,
  type ProfileFormValues,
  type ProfileOperation,
} from "../lib/mappers/profile";
import { ProfileForm } from "./ProfileForm";
import { Skeleton } from "./ui/skeleton";
import { Alert, AlertDescription, AlertTitle } from "./ui/alert";
import { AlertCircle } from "lucide-react";
import type { ApiError } from "../types";

/**
 * ProfileView Component
 *
 * Main view for managing user dietary preferences profile.
 * Handles both create and update modes based on profile existence.
 *
 * Features:
 * - Fetches existing profile from API
 * - Auto-determines create vs update mode
 * - Handles all API errors (401 redirects to /login)
 * - Shows loading states and error alerts
 * - Invalidates cache after successful mutations
 * - Toast notifications for user feedback
 *
 * @component
 */
export default function ProfileView() {
  // Fetch existing profile
  const { data: profile, isLoading, error } = useProfileQuery();

  // Mutations
  const createMutation = useCreateProfileMutation();
  const updateMutation = useUpdateProfileMutation();

  // Determine mode and initial values based on profile data
  const mode: ProfileOperation = profile ? "update" : "create";
  const initialValues: ProfileFormValues = profile ? profileDtoToFormValues(profile) : emptyProfileFormValues();

  if (isLoading) {
    return (
      <div className="space-y-4">
        <Skeleton className="h-12 w-full" />
        <Skeleton className="h-12 w-full" />
        <Skeleton className="h-12 w-full" />
        <Skeleton className="h-10 w-32" />
      </div>
    );
  }

  // Handle form submission
  const handleSubmit = async (values: ProfileFormValues) => {
    try {
      if (mode === "create") {
        const command = formValuesToCreateCommand(values);
        console.log("[ProfileView] Creating profile with command:", command);
        await createMutation.mutateAsync(command);
        toast.success("Profile created successfully!");
        // Query cache will be invalidated automatically, causing re-render with updated data
      } else {
        const command = formValuesToUpdateCommand(values, initialValues);
        console.log("[ProfileView] Updating profile with command:", command);
        console.log("[ProfileView] Current values:", values);
        console.log("[ProfileView] Initial values:", initialValues);

        // Check if there are any changes
        if (Object.keys(command).length === 0) {
          toast.info("No changes to save");
          return;
        }

        await updateMutation.mutateAsync(command);
        toast.success("Profile updated successfully!");
        // Query cache will be invalidated automatically, causing re-render with updated data
      }
    } catch (err) {
      const apiError = err as ApiError;

      // Handle conflict (409) - profile already exists when trying to create
      if (apiError.error === "Conflict") {
        toast.error("Profile already exists. Please refresh the page.");
        // Query will be invalidated automatically
        return;
      }

      // Handle validation errors (400)
      if (apiError.error === "Bad Request" || apiError.message === "Validation failed") {
        toast.error(apiError.message || "Validation error. Please check your input.");
        return;
      }

      // Handle other errors
      toast.error(apiError.message || "An error occurred. Please try again.");
    }
  };

  // Show error state for non-404 errors
  if (error && (error as ApiError).error !== "Not Found") {
    return (
      <Alert variant="destructive">
        <AlertCircle className="h-4 w-4" />
        <AlertTitle>Error</AlertTitle>
        <AlertDescription>
          {(error as ApiError).message || "Failed to load profile. Please try again."}
        </AlertDescription>
      </Alert>
    );
  }

  const isSubmitting = createMutation.isPending || updateMutation.isPending;

  return (
    <div className="space-y-6">
      {mode === "create" && (
        <Alert>
          <AlertCircle className="h-4 w-4" />
          <AlertTitle>Create Your Profile</AlertTitle>
          <AlertDescription>
            Set up your dietary preferences to get personalized recipe recommendations.
          </AlertDescription>
        </Alert>
      )}

      <ProfileForm
        initialValues={initialValues}
        mode={mode}
        onSubmit={handleSubmit}
      />

      {isSubmitting && (
        <div className="text-sm text-muted-foreground">
          Saving...
        </div>
      )}
    </div>
  );
}



================================================
FILE: src/components/QueryProvider.tsx
================================================
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { useState } from "react";

interface QueryProviderProps {
  children: React.ReactNode;
}

export default function QueryProvider({ children }: QueryProviderProps) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            // Disable automatic refetching on window focus for now
            refetchOnWindowFocus: false,
            // Keep data in cache for 5 minutes
            staleTime: 5 * 60 * 1000,
            // Retry failed requests once
            retry: 1,
          },
        },
      })
  );

  return <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>;
}



================================================
FILE: src/components/Welcome.astro
================================================
<div
  class="relative w-full mx-auto min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-blue-900 p-4 sm:p-8"
>
  <div
    class="relative max-w-4xl mx-auto backdrop-blur-xl bg-gradient-to-b from-white/10 to-white/5 rounded-2xl shadow-2xl p-8 text-white border border-white/10"
  >
    <div class="space-y-8">
      <div class="text-center">
        <h1
          class="text-6xl font-bold mb-4 bg-gradient-to-r from-blue-200 via-purple-200 to-pink-200 text-transparent bg-clip-text drop-shadow-lg"
        >
          Witaj w 10xDevs Astro Starter!
        </h1>
        <p class="text-xl text-blue-100/90 drop-shadow-md">
          Ten projekt został zbudowany w oparciu o nowoczesny stack technologiczny:
        </p>
      </div>

      <div class="flex flex-col gap-6 max-w-2xl mx-auto">
        <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-lg rounded-xl p-6 border border-white/10">
          <h2
            class="text-2xl font-semibold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-200 to-purple-200"
          >
            Core
          </h2>
          <ul class="space-y-3">
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">Astro v5.5.5</span>
              <span class="text-blue-100/90">- Metaframework do aplikacji webowych</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">React v19</span>
              <span class="text-blue-100/90">- Biblioteka UI do komponentów interaktywnych</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">TypeScript</span>
              <span class="text-blue-100/90">- Typowanie statyczne</span>
            </li>
          </ul>
        </div>

        <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-lg rounded-xl p-6 border border-white/10">
          <h2
            class="text-2xl font-semibold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-200 to-purple-200"
          >
            Stylowanie
          </h2>
          <ul class="space-y-3">
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm"
                >Tailwind CSS v4</span
              >
              <span class="text-blue-100/90">- Utility-first CSS framework</span>
            </li>
          </ul>
        </div>

        <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-lg rounded-xl p-6 border border-white/10">
          <h2
            class="text-2xl font-semibold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-200 to-purple-200"
          >
            Statyczna analiza kodu
          </h2>
          <ul class="space-y-3">
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">ESLint v9</span>
              <span class="text-blue-100/90">- Lintowanie kodu</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">Prettier</span>
              <span class="text-blue-100/90">- Formatowanie kodu</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm"
                >Husky i Lint-staged</span
              >
              <span class="text-blue-100/90">- Automatyczna analiza kodu przed commitowaniem</span>
            </li>
          </ul>
        </div>
      </div>

      <p class="text-lg text-center text-blue-100/90 mt-8 leading-relaxed">
        Starter zawiera wszystko, czego potrzebujesz do rozpoczęcia tworzenia <br class="hidden sm:block" />
        <span class="font-semibold bg-gradient-to-r from-blue-200 to-purple-200 text-transparent bg-clip-text"
          >nowoczesnych aplikacji webowych!</span
        >
      </p>
    </div>
  </div>
</div>



================================================
FILE: src/components/app/AppLayout.tsx
================================================
import { useState, useEffect } from "react";
import { ChevronLeft, ChevronRight, ChevronDown, ChevronUp } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { LeftPanel } from "./LeftPanel";
import { RightPanel } from "./RightPanel";
import { cn } from "@/lib/utils";

interface AppLayoutProps {
  selectedRecipeId?: string;
}

/**
 * AppLayout component - main 2-column master-detail layout
 * Left panel: recipe list with search/filters (collapsible)
 * Right panel: Generator and Preview tabs
 */
export function AppLayout({ selectedRecipeId }: AppLayoutProps) {
  const [currentSelectedId, setCurrentSelectedId] = useState<string | undefined>(
    selectedRecipeId
  );

  // Collapsible left panel state - persisted in localStorage
  const [isLeftPanelCollapsed, setIsLeftPanelCollapsed] = useState(() => {
    if (typeof window !== "undefined") {
      const stored = localStorage.getItem("leftPanelCollapsed");
      return stored === "true";
    }
    return false;
  });

  // Handle recipe selection from list
  const handleRecipeSelect = (id: string) => {
    setCurrentSelectedId(id);
    // Navigate to recipe detail page
    window.history.pushState({}, "", `/app/recipes/${id}`);

    // Auto-collapse left panel on mobile after selecting a recipe
    // This provides better UX on small screens where the panel overlays the preview
    if (typeof window !== "undefined" && window.innerWidth < 1024) {
      setIsLeftPanelCollapsed(true);
      if (typeof window !== "undefined") {
        localStorage.setItem("leftPanelCollapsed", "true");
      }
    }
  };

  // Handle tag click from preview - filter list by tag
  const handleTagClick = (tag: string) => {
    // Update URL to filter by this tag
    const params = new URLSearchParams(window.location.search);
    const currentTags = params.get("tags")?.split(",").filter(Boolean) || [];

    // Add tag if not already present
    if (!currentTags.includes(tag.toLowerCase())) {
      currentTags.push(tag.toLowerCase());
      params.set("tags", currentTags.join(","));

      // Reset offset when changing filters
      params.delete("offset");

      const newUrl = `${window.location.pathname}?${params.toString()}`;
      window.history.pushState({}, "", newUrl);

      // Trigger popstate to update filters
      window.dispatchEvent(new PopStateEvent("popstate"));
    }
  };

  // Handle "Generate first recipe" CTA from empty state
  const handleGenerateClick = () => {
    // Switch to Generator tab in right panel
    console.log("Switch to Generator tab");
    // This could be implemented by adding tab state management
  };

  // Handle recipe deletion - clear selection
  const handleRecipeDeleted = () => {
    setCurrentSelectedId(undefined);
  };

  // Handle recipe generation - clear selection to show new draft
  const handleRecipeGenerated = () => {
    setCurrentSelectedId(undefined);
    // Navigate back to /app to clear recipe ID from URL
    window.history.pushState({}, "", "/app");
  };

  // Toggle left panel collapse state
  const toggleLeftPanel = () => {
    setIsLeftPanelCollapsed((prev) => {
      const newValue = !prev;
      if (typeof window !== "undefined") {
        localStorage.setItem("leftPanelCollapsed", String(newValue));
      }
      return newValue;
    });
  };

  // Keyboard shortcut: Ctrl/Cmd + B to toggle left panel
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if ((e.ctrlKey || e.metaKey) && e.key === "b") {
        e.preventDefault();
        toggleLeftPanel();
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, []);

  return (
    <div className="relative grid lg:grid-cols-[auto_1fr] gap-4 h-full">
      {/* Left Panel - Recipe List (Collapsible) */}
      <div
        className={cn(
          "flex flex-col h-full border rounded-lg bg-card transition-all duration-300 ease-in-out",
          // Desktop behavior - slide left
          "lg:relative",
          isLeftPanelCollapsed
            ? "lg:w-0 lg:overflow-hidden lg:border-0 lg:p-0 lg:gap-0"
            : "lg:w-[420px]",
          // Mobile behavior - slide from top with overlay (below header)
          "fixed lg:static left-0 right-0 z-40",
          "max-lg:top-16 max-lg:h-[calc(100vh-5rem)] max-lg:mx-4 max-lg:shadow-xl",
          isLeftPanelCollapsed
            ? "max-lg:-translate-y-[calc(100%+5rem)] max-lg:opacity-0 max-lg:pointer-events-none"
            : "max-lg:translate-y-0 max-lg:opacity-100"
        )}
      >
        <LeftPanel
          selectedId={currentSelectedId}
          onSelect={handleRecipeSelect}
          onGenerateClick={handleGenerateClick}
          onToggleCollapse={toggleLeftPanel}
        />
      </div>

      {/* Toggle Button - Visible when collapsed */}
      {isLeftPanelCollapsed && (
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button
                onClick={toggleLeftPanel}
                variant="outline"
                size="icon"
                className={cn(
                  "fixed z-50 shadow-lg hover:shadow-xl transition-shadow",
                  // Desktop: Fixed to left edge
                  "lg:top-20 lg:left-4",
                  // Mobile: Fixed to top center (below header)
                  "max-lg:top-16 max-lg:left-1/2 max-lg:-translate-x-1/2"
                )}
                aria-label="Show recipe list"
              >
                {/* Desktop icon */}
                <ChevronRight className="h-4 w-4 hidden lg:block" />
                {/* Mobile icon */}
                <ChevronDown className="h-4 w-4 lg:hidden" />
              </Button>
            </TooltipTrigger>
            <TooltipContent side="right" className="hidden lg:block">
              <p>Show recipe list</p>
              <p className="text-xs text-muted-foreground">Ctrl+B</p>
            </TooltipContent>
            <TooltipContent side="bottom" className="lg:hidden">
              <p>Show recipe list</p>
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      )}

      {/* Right Panel - Generator & Preview */}
      <div
        className={cn(
          "flex flex-col h-full border rounded-lg bg-card transition-all duration-300",
          // Hide on mobile when left panel is visible
          !isLeftPanelCollapsed && "max-lg:hidden"
        )}
      >
        <RightPanel
          selectedRecipeId={currentSelectedId}
          onTagClick={handleTagClick}
          onRecipeDeleted={handleRecipeDeleted}
          onRecipeGenerated={handleRecipeGenerated}
        />
      </div>

      {/* Mobile overlay backdrop when panel is open */}
      {!isLeftPanelCollapsed && (
        <div
          className="lg:hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-30 transition-opacity duration-300"
          onClick={toggleLeftPanel}
          aria-hidden="true"
        />
      )}
    </div>
  );
}



================================================
FILE: src/components/app/AppPage.tsx
================================================
import QueryProvider from "../QueryProvider";
import { AppLayout } from "./AppLayout";
import { Toaster } from "../ui/sonner";

interface AppPageProps {
  selectedRecipeId?: string;
}

/**
 * AppPage Component
 *
 * Client-side wrapper for the app layout.
 * Combines QueryProvider, AppLayout, and Toaster into a single island.
 *
 * @component
 */
export function AppPage({ selectedRecipeId }: AppPageProps) {
  return (
    <QueryProvider>
      <AppLayout selectedRecipeId={selectedRecipeId} />
      <Toaster />
    </QueryProvider>
  );
}



================================================
FILE: src/components/app/DeleteButton.tsx
================================================
import { useState } from "react";
import { Button } from "@/components/ui/button";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { Trash2 } from "lucide-react";

interface DeleteButtonProps {
  recipeId: string;
  recipeName: string;
  onDeleted: (id: string) => void;
  loading?: boolean;
}

/**
 * DeleteButton component - deletes saved recipe with confirmation dialog
 * Shows AlertDialog before permanent deletion
 */
export function DeleteButton({
  recipeId,
  recipeName,
  onDeleted,
  loading = false,
}: DeleteButtonProps) {
  const [open, setOpen] = useState(false);

  const handleConfirm = () => {
    onDeleted(recipeId);
    setOpen(false);
  };

  return (
    <AlertDialog open={open} onOpenChange={setOpen}>
      <AlertDialogTrigger asChild>
        <Button
          variant="destructive"
          size="lg"
          className="gap-2"
          disabled={loading}
        >
          <Trash2 className="h-5 w-5" />
          Delete recipe
        </Button>
      </AlertDialogTrigger>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Are you sure?</AlertDialogTitle>
          <AlertDialogDescription>
            This will permanently delete "<strong>{recipeName}</strong>".
            This action cannot be undone.
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel>Cancel</AlertDialogCancel>
          <AlertDialogAction onClick={handleConfirm} className="bg-destructive text-destructive-foreground hover:bg-destructive/90">
            Delete
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}



================================================
FILE: src/components/app/EmptyState.tsx
================================================
import { Button } from "@/components/ui/button";
import { FileText, Sparkles } from "lucide-react";

interface EmptyStateProps {
  message?: string;
  onCta?: () => void;
}

/**
 * EmptyState component - displays when recipe list is empty
 * Shows friendly message and CTA to generate first recipe
 */
export function EmptyState({ message, onCta }: EmptyStateProps) {
  const defaultMessage = "No recipes found";
  const displayMessage = message || defaultMessage;

  return (
    <div className="flex flex-col items-center justify-center py-12 px-4 text-center">
      <div className="rounded-full bg-muted p-6 mb-4">
        <FileText className="h-12 w-12 text-muted-foreground" />
      </div>

      <h3 className="text-lg font-semibold mb-2">{displayMessage}</h3>

      <p className="text-sm text-muted-foreground mb-6 max-w-sm">
        {onCta
          ? "Start your culinary journey! Generate your first recipe using AI."
          : "Try changing filters or search for something else."}
      </p>

      {onCta && (
        <Button onClick={onCta} size="lg" className="gap-2">
          <Sparkles className="h-5 w-5" />
          Generate first recipe
        </Button>
      )}
    </div>
  );
}



================================================
FILE: src/components/app/ErrorPanel.tsx
================================================
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import { AlertCircle, RefreshCw } from "lucide-react";
import type { ApiError } from "@/types";

interface ErrorPanelProps {
  error: ApiError | Error;
  onRetry?: () => void;
}

/**
 * Maps API error codes to user-friendly messages
 */
function getErrorMessage(error: ApiError | Error): {
  title: string;
  description: string;
} {
  // Handle generic Error
  if (error instanceof Error) {
    return {
      title: "An error occurred",
      description: error.message || "Please try again later.",
    };
  }

  // Handle ApiError based on status/message
  const errorMsg = error.message?.toLowerCase() || "";
  const errorType = error.error?.toLowerCase() || "";

  // 400 Bad Request
  if (errorMsg.includes("bad request") || errorMsg.includes("validation")) {
    return {
      title: "Invalid request",
      description: "Check your filters and try again.",
    };
  }

  // 401 Unauthorized (shouldn't happen as it redirects, but just in case)
  if (errorMsg.includes("unauthorized") || errorMsg.includes("401")) {
    return {
      title: "Unauthorized",
      description: "Please log in again.",
    };
  }

  // 404 Not Found
  if (errorMsg.includes("not found") || errorMsg.includes("404")) {
    return {
      title: "Not found",
      description: "Recipe doesn't exist or has been deleted.",
    };
  }

  // 413 Payload Too Large
  if (errorMsg.includes("too large") || errorMsg.includes("413")) {
    return {
      title: "Too large",
      description: "Result exceeds the 200KB limit. Please try again.",
    };
  }

  // 429 Too Many Requests
  if (errorMsg.includes("too many") || errorMsg.includes("429")) {
    return {
      title: "Rate limit exceeded",
      description: "Please wait a moment before trying again.",
    };
  }

  // 500 Internal Server Error
  if (errorMsg.includes("internal") || errorMsg.includes("500")) {
    return {
      title: "Server error",
      description: "We're sorry, something went wrong. Please try again later.",
    };
  }

  // 503 Service Unavailable
  if (errorMsg.includes("unavailable") || errorMsg.includes("503")) {
    return {
      title: "Service unavailable",
      description: "Service is temporarily unavailable. Please try again in a moment.",
    };
  }

  // Generic error
  return {
    title: "An error occurred",
    description: error.message || "Please try again later.",
  };
}

/**
 * ErrorPanel component - displays user-friendly error messages
 * Maps error codes (400/401/404/413/429/500/503) to appropriate messages
 * Provides retry button when applicable
 */
export function ErrorPanel({ error, onRetry }: ErrorPanelProps) {
  const { title, description } = getErrorMessage(error);

  return (
    <div className="py-8">
      <Alert variant="destructive">
        <AlertCircle className="h-4 w-4" />
        <AlertTitle>{title}</AlertTitle>
        <AlertDescription className="mt-2">
          <p>{description}</p>
          {onRetry && (
            <Button
              variant="outline"
              size="sm"
              onClick={onRetry}
              className="mt-4 gap-2"
            >
              <RefreshCw className="h-4 w-4" />
              Try again
            </Button>
          )}
        </AlertDescription>
      </Alert>
    </div>
  );
}



================================================
FILE: src/components/app/GenerateButton.tsx
================================================
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Loader2, Sparkles, AlertCircle, RefreshCw } from "lucide-react";
import type { ApiError } from "@/types";

interface GenerateButtonProps {
  onClick: () => void;
  disabled: boolean;
  loading: boolean;
  error?: ApiError | null;
  onRetry?: () => void;
}

/**
 * Maps API error to user-friendly message for generation
 */
function getGenerationErrorMessage(error: ApiError): {
  title: string;
  description: string;
  canRetry: boolean;
} {
  const errorMsg = error.message?.toLowerCase() || "";

  // 400 Bad Request - validation error
  if (errorMsg.includes("validation") || errorMsg.includes("bad request")) {
    return {
      title: "Invalid prompt",
      description: "Make sure the prompt is between 1-2000 characters and doesn't contain forbidden patterns.",
      canRetry: false,
    };
  }

  // 413 Payload Too Large
  if (errorMsg.includes("too large") || errorMsg.includes("413")) {
    return {
      title: "Result too large",
      description: "Generated recipe exceeds 200KB limit. Try a simpler prompt.",
      canRetry: true,
    };
  }

  // 429 Too Many Requests
  if (errorMsg.includes("too many") || errorMsg.includes("429")) {
    const retryAfter = (error.details?.retry_after as number) || 60;
    return {
      title: "Rate limit exceeded",
      description: `Please wait ${retryAfter} seconds before trying again.`,
      canRetry: false,
    };
  }

  // 503 Service Unavailable
  if (errorMsg.includes("unavailable") || errorMsg.includes("503")) {
    return {
      title: "AI service unavailable",
      description: "AI service is temporarily unavailable. Please try again in a moment.",
      canRetry: true,
    };
  }

  // 500 Internal Server Error
  if (errorMsg.includes("internal") || errorMsg.includes("500")) {
    return {
      title: "Server error",
      description: "We're sorry, something went wrong. Please try again.",
      canRetry: true,
    };
  }

  // Generic error
  return {
    title: "An error occurred",
    description: error.message || "Failed to generate recipe. Please try again.",
    canRetry: true,
  };
}

/**
 * GenerateButton component with loading state and error handling
 * Shows retry indicator and error alerts
 */
export function GenerateButton({
  onClick,
  disabled,
  loading,
  error,
  onRetry,
}: GenerateButtonProps) {
  const errorInfo = error ? getGenerationErrorMessage(error) : null;

  return (
    <div className="space-y-4">
      <Button
        onClick={onClick}
        disabled={disabled || loading}
        className="w-full gap-2"
        size="lg"
      >
        {loading ? (
          <>
            <Loader2 className="h-5 w-5 animate-spin" />
            Generating...
          </>
        ) : (
          <>
            <Sparkles className="h-5 w-5" />
            Generate recipe
          </>
        )}
      </Button>

      {loading && (
        <div className="text-xs text-center text-muted-foreground" aria-live="polite">
          AI is analyzing your prompt and creating a recipe...
          <br />
          This may take a few seconds.
        </div>
      )}

      {error && errorInfo && (
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertTitle>{errorInfo.title}</AlertTitle>
          <AlertDescription className="mt-2">
            <p className="text-sm">{errorInfo.description}</p>
            {errorInfo.canRetry && onRetry && (
              <Button
                variant="outline"
                size="sm"
                onClick={onRetry}
                className="mt-3 gap-2"
              >
                <RefreshCw className="h-4 w-4" />
                Try again
              </Button>
            )}
          </AlertDescription>
        </Alert>
      )}
    </div>
  );
}



================================================
FILE: src/components/app/GeneratorPanel.tsx
================================================
import { useState, useEffect } from "react";
import { TextareaWithCounter } from "./TextareaWithCounter";
import { GenerateButton } from "./GenerateButton";
import { useGenerateRecipeMutation } from "@/lib/api/recipes";
import type { GeneratorDraftVM, GenerateRecipeResponse, ApiError } from "@/types";

interface GeneratorPanelProps {
  onGenerated: (response: GenerateRecipeResponse) => void;
}

/**
 * GeneratorPanel component - AI recipe generation interface
 * Manages prompt input, generation request, and draft state
 */
export function GeneratorPanel({ onGenerated }: GeneratorPanelProps) {
  const [prompt, setPrompt] = useState("");
  const [error, setError] = useState<ApiError | null>(null);

  const generateMutation = useGenerateRecipeMutation();

  // Clear error when prompt changes
  useEffect(() => {
    if (error) {
      setError(null);
    }
  }, [prompt]);

  const handleGenerate = () => {
    if (!prompt.trim() || prompt.length < 1 || prompt.length > 2000) {
      return;
    }

    setError(null);
    generateMutation.mutate(
      { prompt: prompt.trim() },
      {
        onSuccess: (response) => {
          // Save draft to sessionStorage
          const draft: GeneratorDraftVM = {
            prompt: prompt.trim(),
            recipe: response.recipe,
            generationId: response.generation_id,
            generatedAt: response.generated_at,
          };
          sessionStorage.setItem("generatorDraft", JSON.stringify(draft));

          // Notify parent
          onGenerated(response);
        },
        onError: (err) => {
          setError(err as ApiError);
        },
      }
    );
  };

  const handleRetry = () => {
    handleGenerate();
  };

  const isPromptValid = prompt.trim().length >= 1 && prompt.trim().length <= 2000;
  const isDisabled = !isPromptValid || generateMutation.isPending;

  return (
    <div className="space-y-6 p-6">
      <div className="space-y-2">
        <h2 className="text-2xl font-bold">AI Recipe Generator</h2>
        <p className="text-sm text-muted-foreground">
          Describe the recipe you want to create, and AI will generate a detailed recipe for you.
        </p>
      </div>

      <TextareaWithCounter
        value={prompt}
        onChange={setPrompt}
        disabled={generateMutation.isPending}
        maxLength={2000}
        placeholder="E.g. 'Quick dinner for two with chicken and vegetables' or 'Vegan chocolate dessert without sugar'"
      />

      <GenerateButton
        onClick={handleGenerate}
        disabled={isDisabled}
        loading={generateMutation.isPending}
        error={error}
        onRetry={handleRetry}
      />

      {/* Info section */}
      <div className="border-t pt-4">
        <h3 className="text-sm font-semibold mb-2">Tips:</h3>
        <ul className="text-xs text-muted-foreground space-y-1 list-disc list-inside">
          <li>Be specific - describe ingredients, cuisine type, or dietary preferences</li>
          <li>You can specify number of servings, preparation time, or difficulty level</li>
          <li>AI will create a complete recipe with ingredients, instructions, and nutritional info</li>
        </ul>
      </div>
    </div>
  );
}



================================================
FILE: src/components/app/LeftPanel.tsx
================================================
import { useMemo, useCallback } from "react";
import { ChevronLeft, ChevronUp } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { SearchBar } from "./SearchBar";
import { TagFilterChips } from "./TagFilterChips";
import { SortSelect } from "./SortSelect";
import { RecipeList } from "./RecipeList";
import { EmptyState } from "./EmptyState";
import { ErrorPanel } from "./ErrorPanel";
import { RecipeListSkeleton } from "./RecipeListSkeleton";
import { useRecipesList } from "@/lib/api/recipes";
import { useUrlFilters } from "@/lib/hooks/useUrlFilters";
import { useScrollRestoration } from "@/lib/hooks/useScrollRestoration";
import type { ListFiltersVM } from "@/types";

interface LeftPanelProps {
  selectedId?: string;
  onSelect: (id: string) => void;
  onGenerateClick?: () => void;
  onToggleCollapse?: () => void;
}

/**
 * LeftPanel component - recipe list with search, filters, and sorting
 * Integrates all sub-components and manages filter state
 * Supports collapsing for full-screen generator/preview mode
 */
export function LeftPanel({ selectedId, onSelect, onGenerateClick, onToggleCollapse }: LeftPanelProps) {
  // Filter state synced with URL
  const { filters, setFilters } = useUrlFilters();

  // Scroll restoration for recipe list
  const scrollContainerRef = useScrollRestoration<HTMLDivElement>(
    typeof window !== "undefined" ? window.location.search : ""
  );

  // Fetch recipes with current filters
  const {
    data,
    isLoading,
    isError,
    error,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
    refetch,
  } = useRecipesList({
    search: filters.search || undefined,
    tags: filters.tags.length > 0 ? filters.tags.join(",") : undefined,
    sort: filters.sort,
    limit: filters.limit,
  });

  // Aggregate all unique tags from results
  const allTags = useMemo(() => {
    if (!data?.pages) return [];

    const tagSet = new Set<string>();
    data.pages.forEach((page) => {
      page.data.forEach((recipe) => {
        recipe.tags?.forEach((tag) => tagSet.add(tag));
      });
    });

    return Array.from(tagSet).sort();
  }, [data]);

  // Filter handlers
  const handleSearchChange = useCallback((search: string) => {
    setFilters((prev) => ({ ...prev, search, offset: 0 }));
  }, []);

  const handleSearchSubmit = useCallback(() => {
    // Trigger refetch on submit
    refetch();
  }, [refetch]);

  const handleTagsChange = useCallback((tags: string[]) => {
    setFilters((prev) => ({ ...prev, tags, offset: 0 }));
  }, []);

  const handleSortChange = useCallback((sort: "recent" | "oldest") => {
    setFilters((prev) => ({ ...prev, sort, offset: 0 }));
  }, []);

  const handleLoadMore = useCallback(() => {
    if (hasNextPage && !isFetchingNextPage) {
      fetchNextPage();
    }
  }, [hasNextPage, isFetchingNextPage, fetchNextPage]);

  const handleRetry = useCallback(() => {
    refetch();
  }, [refetch]);

  const pages = data?.pages || [];
  const totalRecipes = pages.reduce((acc, page) => acc + page.data.length, 0);
  const hasFilters = filters.search || filters.tags.length > 0;

  return (
    <div className="flex flex-col h-full">
      {/* Header with title and collapse button */}
      <div className="flex items-center justify-between px-4 py-3 border-b">
        <h2 className="text-lg font-semibold">Your Recipes</h2>
        {onToggleCollapse && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  onClick={onToggleCollapse}
                  variant="ghost"
                  size="icon"
                  className="h-8 w-8 -mr-2"
                  aria-label="Hide recipe list"
                >
                  {/* Desktop icon */}
                  <ChevronLeft className="h-4 w-4 hidden lg:block" />
                  {/* Mobile icon */}
                  <ChevronUp className="h-4 w-4 lg:hidden" />
                </Button>
              </TooltipTrigger>
              <TooltipContent side="left" className="hidden lg:block">
                <p>Hide recipe list</p>
                <p className="text-xs text-muted-foreground">Ctrl+B</p>
              </TooltipContent>
              <TooltipContent side="bottom" className="lg:hidden">
                <p>Hide recipe list</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
      </div>

      {/* Filters Section */}
      <div className="space-y-3 p-4 lg:pb-4 max-lg:pb-3 border-b">
        <SearchBar
          value={filters.search || ""}
          onChange={handleSearchChange}
          onSubmit={handleSearchSubmit}
        />

        <TagFilterChips
          selected={filters.tags}
          allTags={allTags}
          onChange={handleTagsChange}
        />

        <SortSelect value={filters.sort} onChange={handleSortChange} />
      </div>

      {/* Results Section */}
      <div ref={scrollContainerRef} className="flex-1 overflow-y-auto p-4 max-lg:p-3 min-h-0">
        {isLoading ? (
          <RecipeListSkeleton count={3} />
        ) : isError ? (
          <ErrorPanel error={error as Error} onRetry={handleRetry} />
        ) : totalRecipes === 0 ? (
          <EmptyState
            message={
              hasFilters
                ? "No recipes matching your filters"
                : "No recipes yet"
            }
            onCta={!hasFilters ? onGenerateClick : undefined}
          />
        ) : (
          <RecipeList
            pages={pages}
            isLoading={isLoading}
            isError={isError}
            selectedId={selectedId}
            onSelect={onSelect}
            onLoadMore={handleLoadMore}
            hasNextPage={hasNextPage || false}
            isFetchingNextPage={isFetchingNextPage}
          />
        )}
      </div>
    </div>
  );
}



================================================
FILE: src/components/app/PaginationLoadMore.tsx
================================================
import { Button } from "@/components/ui/button";
import { Loader2 } from "lucide-react";

interface PaginationLoadMoreProps {
  hasMore: boolean;
  isLoading: boolean;
  onClick: () => void;
}

/**
 * PaginationLoadMore component - "Load More" button for infinite scroll
 * Shows loading state and disables when no more results
 */
export function PaginationLoadMore({
  hasMore,
  isLoading,
  onClick,
}: PaginationLoadMoreProps) {
  if (!hasMore && !isLoading) {
    return null;
  }

  return (
    <div className="flex justify-center py-4">
      <Button
        variant="outline"
        onClick={onClick}
        disabled={isLoading || !hasMore}
        className="min-w-[200px]"
      >
        {isLoading ? (
          <>
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
            Loading...
          </>
        ) : (
          "Load more"
        )}
      </Button>
    </div>
  );
}



================================================
FILE: src/components/app/PreviewPanel.tsx
================================================
import { RecipePreview } from "./RecipePreview";
import { SaveButton } from "./SaveButton";
import { DeleteButton } from "./DeleteButton";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { FileText, RotateCcw } from "lucide-react";
import { useSaveRecipeMutation, useDeleteRecipeMutation } from "@/lib/api/recipes";
import { useProfileQuery } from "@/lib/api/profile";
import type {
  RecipeSchema,
  RecipeDetailsDTO,
  RecipeSummaryDTO,
  PreviewMode,
} from "@/types";
import { toast } from "sonner";

interface PreviewPanelProps {
  mode: PreviewMode;
  recipe?: RecipeSchema;
  details?: RecipeDetailsDTO;
  onSaved?: (summary: RecipeSummaryDTO) => void;
  onDeleted?: (id: string) => void;
  onTagClick?: (tag: string) => void;
  onRestoreDraft?: () => void;
}

/**
 * PreviewPanel component - displays recipe preview with actions
 * Modes: 'draft' (from generator) or 'saved' (from database)
 * Handles save, delete, and tag filtering
 */
export function PreviewPanel({
  mode,
  recipe,
  details,
  onSaved,
  onDeleted,
  onTagClick,
  onRestoreDraft,
}: PreviewPanelProps) {
  const { data: profile } = useProfileQuery();
  const saveMutation = useSaveRecipeMutation();
  const deleteMutation = useDeleteRecipeMutation();

  // Check if recipe contains disliked ingredients
  const checkDislikedIngredients = (recipeData: RecipeSchema): string | null => {
    if (!profile?.disliked_ingredients || profile.disliked_ingredients.length === 0) {
      return null;
    }

    const dislikedList = profile.disliked_ingredients.map((i) => i.toLowerCase());
    const ingredientsList = recipeData.ingredients.map((i) => i.toLowerCase());

    const found = dislikedList.find((disliked) =>
      ingredientsList.some((ingredient) => ingredient.includes(disliked))
    );

    if (found) {
      return `This recipe contains "${found}" which is in your disliked ingredients list.`;
    }

    return null;
  };

  const handleSave = () => {
    if (!recipe) return;

    saveMutation.mutate(
      { recipe, tags: recipe.tags },
      {
        onSuccess: (summary) => {
          toast.success("Recipe saved successfully!");
          onSaved?.(summary);
        },
        onError: (error: any) => {
          toast.error(error.message || "Failed to save recipe");
        },
      }
    );
  };

  const handleDelete = (id: string) => {
    deleteMutation.mutate(id, {
      onSuccess: () => {
        toast.success("Recipe deleted successfully!");
        onDeleted?.(id);
      },
      onError: (error: any) => {
        toast.error(error.message || "Failed to delete recipe");
      },
    });
  };

  // Empty state
  if (!recipe && !details) {
    return (
      <div className="flex flex-col items-center justify-center h-full p-6 text-center">
        <div className="rounded-full bg-muted p-6 mb-4">
          <FileText className="h-12 w-12 text-muted-foreground" />
        </div>
        <h3 className="text-lg font-semibold mb-2">No recipe selected</h3>
        <p className="text-sm text-muted-foreground max-w-sm">
          Select a recipe from the list or generate a new one using AI to see it here.
        </p>
      </div>
    );
  }

  const displayData = mode === "saved" && details ? details : recipe;
  if (!displayData) return null;

  const disabledReason = mode === "draft" && recipe ? checkDislikedIngredients(recipe) : null;
  const canSave = mode === "draft" && !disabledReason;

  return (
    <div className="h-full overflow-y-auto">
      <div className="p-6 space-y-6">
        {/* Disliked ingredients warning */}
        {disabledReason && (
          <Alert>
            <AlertDescription>{disabledReason}</AlertDescription>
          </Alert>
        )}

        {/* Recipe preview */}
        <RecipePreview
          data={displayData}
          onTagClick={onTagClick}
          readonly={mode === "saved"}
        />

        {/* Actions bar - bottom */}
        <div className="flex items-center justify-between gap-3 pt-6 border-t">
          {/* Left side - primary actions (Save, Edit) */}
          <div className="flex flex-wrap gap-3">
            {mode === "draft" && recipe && (
              <>
                <SaveButton
                  onClick={handleSave}
                  disabled={!canSave || saveMutation.isPending}
                  loading={saveMutation.isPending}
                  disabledReason={disabledReason || undefined}
                />
                {onRestoreDraft && (
                  <Button
                    variant="outline"
                    size="lg"
                    onClick={onRestoreDraft}
                    className="gap-2"
                  >
                    <RotateCcw className="h-5 w-5" />
                    Restore from draft
                  </Button>
                )}
              </>
            )}
          </div>

          {/* Right side - destructive actions (Delete) */}
          <div className="flex flex-wrap gap-3">
            {mode === "saved" && details && (
              <DeleteButton
                recipeId={details.id}
                recipeName={details.title}
                onDeleted={handleDelete}
                loading={deleteMutation.isPending}
              />
            )}
          </div>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: src/components/app/RecipeCard.tsx
================================================
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import type { RecipeListItemDTO } from "@/types";

interface RecipeCardProps {
  item: RecipeListItemDTO;
  selected?: boolean;
  onClick: () => void;
}

/**
 * RecipeCard component - displays a single recipe in the list
 * Shows title, summary, and tags
 */
export function RecipeCard({ item, selected = false, onClick }: RecipeCardProps) {
  return (
    <Card
      className={`p-4 cursor-pointer transition-colors hover:bg-accent ${
        selected ? "border-primary bg-accent" : ""
      }`}
      onClick={onClick}
      role="button"
      tabIndex={0}
      onKeyDown={(e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          onClick();
        }
      }}
      aria-pressed={selected}
    >
      <div className="space-y-2">
        <h3 className="font-semibold text-lg line-clamp-2">{item.title}</h3>

        {item.summary && (
          <p className="text-sm text-muted-foreground line-clamp-2">{item.summary}</p>
        )}

        {item.tags && item.tags.length > 0 && (
          <div className="flex flex-wrap gap-1">
            {item.tags.map((tag) => (
              <Badge key={tag} variant="secondary" className="text-xs">
                {tag}
              </Badge>
            ))}
          </div>
        )}
      </div>
    </Card>
  );
}



================================================
FILE: src/components/app/RecipeList.tsx
================================================
import { RecipeCard } from "./RecipeCard";
import { PaginationLoadMore } from "./PaginationLoadMore";
import type { RecipeListResponse } from "@/types";

interface RecipeListProps {
  pages: RecipeListResponse[];
  isLoading: boolean;
  isError: boolean;
  selectedId?: string;
  onSelect: (id: string) => void;
  onLoadMore: () => void;
  hasNextPage: boolean;
  isFetchingNextPage: boolean;
}

/**
 * RecipeList component - displays paginated list of recipe cards
 * Supports infinite scroll with "Load More" button
 * Shows loading skeletons and error states
 */
export function RecipeList({
  pages,
  isLoading,
  isError,
  selectedId,
  onSelect,
  onLoadMore,
  hasNextPage,
  isFetchingNextPage,
}: RecipeListProps) {
  // Flatten all pages into single array
  const allRecipes = pages.flatMap((page) => page.data);

  if (isError) {
    return null; // Error handled by ErrorPanel in parent
  }

  if (isLoading) {
    return null; // Loading handled by Skeleton in parent
  }

  if (allRecipes.length === 0) {
    return null; // Empty state handled by EmptyState in parent
  }

  return (
    <div className="space-y-3">
      <ul className="space-y-3" role="list">
        {allRecipes.map((recipe) => (
          <li key={recipe.id}>
            <RecipeCard
              item={recipe}
              selected={selectedId === recipe.id}
              onClick={() => onSelect(recipe.id)}
            />
          </li>
        ))}
      </ul>

      <PaginationLoadMore
        hasMore={hasNextPage}
        isLoading={isFetchingNextPage}
        onClick={onLoadMore}
      />

      {/* Announce results count for screen readers */}
      <div className="sr-only" aria-live="polite" aria-atomic="true">
        Found {allRecipes.length} {allRecipes.length === 1 ? "recipe" : "recipes"}
      </div>
    </div>
  );
}



================================================
FILE: src/components/app/RecipeListSkeleton.tsx
================================================
import { Skeleton } from "@/components/ui/skeleton";
import { Card } from "@/components/ui/card";

interface RecipeListSkeletonProps {
  count?: number;
}

/**
 * RecipeListSkeleton component - loading state for recipe list
 * Shows skeleton cards matching the RecipeCard layout
 */
export function RecipeListSkeleton({ count = 3 }: RecipeListSkeletonProps) {
  return (
    <div className="space-y-3">
      {Array.from({ length: count }).map((_, index) => (
        <Card key={index} className="p-4">
          <div className="space-y-2">
            {/* Title */}
            <Skeleton className="h-6 w-3/4" />

            {/* Summary */}
            <Skeleton className="h-4 w-full" />
            <Skeleton className="h-4 w-5/6" />

            {/* Tags */}
            <div className="flex gap-1 pt-1">
              <Skeleton className="h-5 w-16" />
              <Skeleton className="h-5 w-20" />
              <Skeleton className="h-5 w-12" />
            </div>

            {/* Date */}
            <Skeleton className="h-3 w-32 mt-2" />
          </div>
        </Card>
      ))}
      <div className="sr-only" aria-live="polite">
        Loading recipes...
      </div>
    </div>
  );
}



================================================
FILE: src/components/app/RecipePreview.tsx
================================================
import { useState } from "react";
import { Badge } from "@/components/ui/badge";
import { Clock, Users, ChefHat, Flame, CheckCircle2, Beef, Wheat, Droplet } from "lucide-react";
import { cn } from "@/lib/utils";
import type { RecipeSchema, RecipeDetailsDTO } from "@/types";

interface RecipePreviewProps {
  data: RecipeSchema | RecipeDetailsDTO;
  onTagClick?: (tag: string) => void;
  readonly?: boolean;
}

/**
 * RecipePreview component - renders recipe JSON to semantic HTML
 * Displays title, times, servings, attributes, ingredients, instructions, and tags
 * Interactive: servings adjuster, checkable ingredients and steps
 */
export function RecipePreview({ data, onTagClick, readonly = false }: RecipePreviewProps) {
  const recipe = "recipe" in data ? (data as RecipeDetailsDTO).recipe : (data as RecipeSchema);
  const tags = "tags" in data && Array.isArray(data.tags) ? data.tags : recipe.tags || [];

  // Deterministic color palette for tags (hash-based)
  const tagColorPalette = [
    "bg-blue-100 text-blue-700 dark:bg-blue-950/40 dark:text-blue-300 border-blue-200 dark:border-blue-800",
    "bg-purple-100 text-purple-700 dark:bg-purple-950/40 dark:text-purple-300 border-purple-200 dark:border-purple-800",
    "bg-pink-100 text-pink-700 dark:bg-pink-950/40 dark:text-pink-300 border-pink-200 dark:border-pink-800",
    "bg-orange-100 text-orange-700 dark:bg-orange-950/40 dark:text-orange-300 border-orange-200 dark:border-orange-800",
    "bg-teal-100 text-teal-700 dark:bg-teal-950/40 dark:text-teal-300 border-teal-200 dark:border-teal-800",
    "bg-cyan-100 text-cyan-700 dark:bg-cyan-950/40 dark:text-cyan-300 border-cyan-200 dark:border-cyan-800",
    "bg-indigo-100 text-indigo-700 dark:bg-indigo-950/40 dark:text-indigo-300 border-indigo-200 dark:border-indigo-800",
    "bg-lime-100 text-lime-700 dark:bg-lime-950/40 dark:text-lime-300 border-lime-200 dark:border-lime-800",
  ];

  // Simple hash function for deterministic color assignment
  const getTagColor = (tag: string) => {
    let hash = 0;
    for (let i = 0; i < tag.length; i++) {
      hash = tag.charCodeAt(i) + ((hash << 5) - hash);
    }
    return tagColorPalette[Math.abs(hash) % tagColorPalette.length];
  };

  // Interactive state
  const [currentServings, setCurrentServings] = useState(recipe.servings);
  const [completedIngredients, setCompletedIngredients] = useState<Set<number>>(new Set());
  const [completedSteps, setCompletedSteps] = useState<Set<number>>(new Set());

  // Scaling ratio for ingredients and nutrition
  const scalingRatio = currentServings / recipe.servings;

  // Helper to scale ingredient strings (looks for numbers and scales them)
  const scaleIngredient = (ingredient: string) => {
    if (scalingRatio === 1) return ingredient;
    return ingredient.replace(/(\d+(\.\d+)?)/g, (match) => {
      const num = parseFloat(match);
      const scaled = num * scalingRatio;
      return Number.isInteger(scaled) ? scaled.toString() : scaled.toFixed(1).replace(/\.0$/, '');
    });
  };

  const toggleIngredient = (index: number) => {
    const next = new Set(completedIngredients);
    if (next.has(index)) next.delete(index);
    else next.add(index);
    setCompletedIngredients(next);
  };

  const toggleStep = (index: number) => {
    const next = new Set(completedSteps);
    if (next.has(index)) next.delete(index);
    else next.add(index);
    setCompletedSteps(next);
  };

  const difficultyColors = {
    easy: "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300",
    medium: "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-300",
    hard: "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300",
  };

  return (
    <article className="space-y-6">
      {/* Header */}
      <div className="space-y-4">
        <div className="space-y-2">
          <h1 className="text-3xl md:text-4xl font-bold text-foreground">{recipe.title}</h1>
          {recipe.cuisine && (
            <p className="text-muted-foreground/70 italic text-sm">{recipe.cuisine}</p>
          )}
        </div>

        {recipe.summary && (
          <p className="text-lg text-muted-foreground leading-relaxed">{recipe.summary}</p>
        )}

        {recipe.description && (
          <p className="text-muted-foreground leading-relaxed">{recipe.description}</p>
        )}

        {/* Tags and Dietary Info */}
        {(tags.length > 0 || (recipe.dietary_info && Object.keys(recipe.dietary_info).length > 0)) && (
          <div className="flex flex-wrap gap-2">
            {/* Dietary info badges - pill style with border-2 */}
            {recipe.dietary_info && Object.entries(recipe.dietary_info).map(
              ([key, value]) =>
                value && (
                  <Badge
                    key={key}
                    variant="outline"
                    className="rounded-full border-2 bg-emerald-50 text-emerald-700 border-emerald-300 dark:bg-emerald-950/40 dark:text-emerald-300 dark:border-emerald-700 px-3"
                  >
                    {key.replace(/_/g, " ")}
                  </Badge>
                )
            )}

            {/* Regular tags - square with rounded corners */}
            {tags.map((tag) => (
              <Badge
                key={tag}
                variant="outline"
                className={cn(
                  "transition-all border",
                  getTagColor(tag),
                  onTagClick && !readonly && "cursor-pointer hover:scale-105 hover:shadow-sm"
                )}
                onClick={() => !readonly && onTagClick?.(tag)}
                role={onTagClick && !readonly ? "button" : undefined}
                tabIndex={onTagClick && !readonly ? 0 : undefined}
                onKeyDown={(e) => {
                  if (!readonly && onTagClick && (e.key === "Enter" || e.key === " ")) {
                    e.preventDefault();
                    onTagClick(tag);
                  }
                }}
              >
                {tag}
              </Badge>
            ))}
          </div>
        )}

        {/* Meta information with servings adjuster */}
        <div className="flex flex-wrap items-center gap-4 text-sm">
          <div className="flex items-center gap-2 text-muted-foreground">
            <Clock className="h-4 w-4" />
            <span>
              Prep: {recipe.prep_time_minutes}m | Cook: {recipe.cook_time_minutes}m
            </span>
          </div>

          <div className="flex items-center gap-2">
            <ChefHat className="h-4 w-4 text-muted-foreground" />
            <Badge className={difficultyColors[recipe.difficulty]}>
              {recipe.difficulty}
            </Badge>
          </div>

          {/* Servings Adjuster */}
          <div className="flex items-center gap-3 bg-primary/5 dark:bg-primary/10 py-2 px-4 rounded-full border border-primary/20">
            <Users className="h-4 w-4 text-primary" />
            <span className="text-sm text-muted-foreground font-medium uppercase tracking-wide">Serves:</span>
            <div className="flex items-center gap-3">
              <button
                onClick={() => setCurrentServings(Math.max(1, currentServings - 1))}
                className="w-6 h-6 flex items-center justify-center rounded-full bg-primary/10 text-primary hover:bg-primary/20 transition-colors active:scale-95"
                aria-label="Decrease servings"
              >
                -
              </button>
              <span className="font-bold text-foreground min-w-[1.5rem] text-center">{currentServings}</span>
              <button
                onClick={() => setCurrentServings(currentServings + 1)}
                className="w-6 h-6 flex items-center justify-center rounded-full bg-primary/10 text-primary hover:bg-primary/20 transition-colors active:scale-95"
                aria-label="Increase servings"
              >
                +
              </button>
            </div>
          </div>
        </div>
      </div>

      {/* Ingredients */}
      <section className="border-t pt-6">
        <div className="flex items-center justify-between mb-4">
          <h2 className="text-xl font-bold text-foreground">Ingredients</h2>
          <span className="text-sm text-muted-foreground">
            {completedIngredients.size} of {recipe.ingredients.length}
          </span>
        </div>

        <ul className="space-y-3">
          {recipe.ingredients.map((ingredient, index) => {
            const isChecked = completedIngredients.has(index);
            return (
              <li key={index}>
                <button
                  onClick={() => toggleIngredient(index)}
                  className={cn(
                    "group flex items-start gap-3 w-full text-left p-3 rounded-xl transition-all duration-200",
                    isChecked
                      ? "bg-emerald-50 dark:bg-emerald-950/30 text-emerald-800 dark:text-emerald-200"
                      : "hover:bg-accent bg-transparent"
                  )}
                >
                  <div
                    className={cn(
                      "mt-0.5 flex-shrink-0 w-5 h-5 rounded-full border-2 flex items-center justify-center transition-colors",
                      isChecked
                        ? "border-emerald-500 bg-emerald-500"
                        : "border-border group-hover:border-primary"
                    )}
                  >
                    {isChecked && <CheckCircle2 className="w-4 h-4 text-white" />}
                  </div>
                  <span
                    className={cn(
                      "text-foreground leading-relaxed transition-opacity",
                      isChecked && "line-through opacity-70"
                    )}
                  >
                    {scaleIngredient(ingredient)}
                  </span>
                </button>
              </li>
            );
          })}
        </ul>
      </section>

      {/* Instructions */}
      <section className="border-t pt-6">
        <div className="flex items-center justify-between mb-6">
          <h2 className="text-2xl font-bold text-foreground">Instructions</h2>
          <div className="text-sm font-medium px-3 py-1 bg-primary/10 dark:bg-primary/20 text-primary rounded-full">
            Step {completedSteps.size < recipe.instructions.length ? completedSteps.size + 1 : recipe.instructions.length} of {recipe.instructions.length}
          </div>
        </div>

        <ol className="space-y-6">
          {recipe.instructions.map((instruction, index) => {
            const isCompleted = completedSteps.has(index);
            return (
              <li key={index} className="relative flex gap-4 sm:gap-6 group">
                {/* Step connector line */}
                {index !== recipe.instructions.length - 1 && (
                  <div
                    className={cn(
                      "absolute left-4 top-10 bottom-0 w-0.5 -ml-px",
                      isCompleted ? "bg-primary/30" : "bg-border"
                    )}
                    aria-hidden="true"
                  />
                )}

                <button
                  onClick={() => toggleStep(index)}
                  className={cn(
                    "flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center text-sm font-bold border-2 transition-all z-10",
                    isCompleted
                      ? "bg-primary border-primary text-primary-foreground ring-4 ring-primary/20"
                      : "bg-background border-border text-primary group-hover:border-primary"
                  )}
                  aria-label={`Toggle step ${index + 1}`}
                >
                  {isCompleted ? <CheckCircle2 className="w-5 h-5" /> : index + 1}
                </button>

                <div
                  className={cn(
                    "flex-grow pt-1 pb-6 transition-opacity duration-300",
                    isCompleted ? "opacity-50" : "opacity-100"
                  )}
                >
                  <p
                    className={cn(
                      "text-foreground leading-relaxed text-lg",
                      isCompleted && "line-through decoration-muted-foreground/30"
                    )}
                  >
                    {instruction}
                  </p>
                </div>
              </li>
            );
          })}
        </ol>

        {/* Completion State */}
        {completedSteps.size === recipe.instructions.length && (
          <div className="mt-8 p-6 bg-emerald-50 dark:bg-emerald-950/30 rounded-2xl border border-emerald-200 dark:border-emerald-800 text-center">
            <ChefHat className="w-12 h-12 text-emerald-500 dark:text-emerald-400 mx-auto mb-3" />
            <h3 className="text-xl font-bold text-emerald-900 dark:text-emerald-100 mb-1">Bon Appétit!</h3>
            <p className="text-emerald-700 dark:text-emerald-300">You've completed this recipe.</p>
          </div>
        )}
      </section>

      {/* Nutrition */}
      {recipe.nutrition && Object.keys(recipe.nutrition).length > 0 && (
        <section className="border-t pt-6">
          <h2 className="text-sm font-bold text-foreground uppercase tracking-wider mb-4 flex items-center gap-2">
            <Flame className="w-4 h-4 text-orange-500" />
            Nutrition per serving
          </h2>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            {recipe.nutrition.calories !== undefined && (
              <div className="bg-card dark:bg-card p-4 rounded-lg shadow-sm border border-border flex flex-col">
                <span className="text-xs text-muted-foreground font-medium uppercase mb-1">Calories</span>
                <div className="flex items-end">
                  <span className="text-2xl font-bold text-foreground leading-none mr-1">
                    {Math.round((recipe.nutrition.calories * scalingRatio) / currentServings * recipe.servings)}
                  </span>
                  <span className="text-sm text-muted-foreground font-medium pb-0.5">kcal</span>
                </div>
              </div>
            )}
            {recipe.nutrition.protein_g !== undefined && (
              <div className="bg-card dark:bg-card p-4 rounded-lg shadow-sm border border-border flex flex-col">
                <span className="text-xs text-muted-foreground font-medium uppercase mb-1 flex items-center">
                  <Beef className="w-3 h-3 mr-1 text-red-400" /> Protein
                </span>
                <div className="flex items-end">
                  <span className="text-2xl font-bold text-foreground leading-none mr-1">
                    {Math.round((recipe.nutrition.protein_g * scalingRatio) / currentServings * recipe.servings)}
                  </span>
                  <span className="text-sm text-muted-foreground font-medium pb-0.5">g</span>
                </div>
              </div>
            )}
            {recipe.nutrition.carbs_g !== undefined && (
              <div className="bg-card dark:bg-card p-4 rounded-lg shadow-sm border border-border flex flex-col">
                <span className="text-xs text-muted-foreground font-medium uppercase mb-1 flex items-center">
                  <Wheat className="w-3 h-3 mr-1 text-amber-400" /> Carbs
                </span>
                <div className="flex items-end">
                  <span className="text-2xl font-bold text-foreground leading-none mr-1">
                    {Math.round((recipe.nutrition.carbs_g * scalingRatio) / currentServings * recipe.servings)}
                  </span>
                  <span className="text-sm text-muted-foreground font-medium pb-0.5">g</span>
                </div>
              </div>
            )}
            {recipe.nutrition.fat_g !== undefined && (
              <div className="bg-card dark:bg-card p-4 rounded-lg shadow-sm border border-border flex flex-col">
                <span className="text-xs text-muted-foreground font-medium uppercase mb-1 flex items-center">
                  <Droplet className="w-3 h-3 mr-1 text-yellow-500" /> Fat
                </span>
                <div className="flex items-end">
                  <span className="text-2xl font-bold text-foreground leading-none mr-1">
                    {Math.round((recipe.nutrition.fat_g * scalingRatio) / currentServings * recipe.servings)}
                  </span>
                  <span className="text-sm text-muted-foreground font-medium pb-0.5">g</span>
                </div>
              </div>
            )}
          </div>
          <p className="text-xs text-muted-foreground/70 mt-4 text-center">
            Nutritional values are approximate and may differ from actual values.
          </p>
        </section>
      )}
    </article>
  );
}



================================================
FILE: src/components/app/RightPanel.tsx
================================================
import { useState, useEffect } from "react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { GeneratorPanel } from "./GeneratorPanel";
import { PreviewPanel } from "./PreviewPanel";
import { useRecipeDetails } from "@/lib/api/recipes";
import type {
  RecipeSchema,
  GenerateRecipeResponse,
  RecipeSummaryDTO,
} from "@/types";

interface RightPanelProps {
  selectedRecipeId?: string;
  onTagClick?: (tag: string) => void;
  onRecipeDeleted?: () => void;
  onRecipeGenerated?: () => void;
}

type ActiveTab = "generator" | "preview";

/**
 * RightPanel component - tabbed interface for Generator and Preview
 * Auto-switches to Preview after successful generation
 * Supports deep-linking to saved recipe details
 */
export function RightPanel({ selectedRecipeId, onTagClick, onRecipeDeleted, onRecipeGenerated }: RightPanelProps) {
  const [activeTab, setActiveTab] = useState<ActiveTab>("preview");
  const [draftRecipe, setDraftRecipe] = useState<RecipeSchema | undefined>();

  // Fetch selected recipe details (if deep-linked)
  const {
    data: selectedRecipe,
    isLoading: isLoadingRecipe,
    isError: isRecipeError,
  } = useRecipeDetails(selectedRecipeId || "");

  // Switch to preview when recipe is selected via deep-link
  useEffect(() => {
    if (selectedRecipeId && selectedRecipe) {
      setActiveTab("preview");
    }
  }, [selectedRecipeId, selectedRecipe]);

  // Handle hash navigation (#generator)
  useEffect(() => {
    const handleHashChange = () => {
      if (window.location.hash === "#generator") {
        setActiveTab("generator");
        // Clear hash without adding to history
        window.history.replaceState(null, "", window.location.pathname + window.location.search);
      }
    };

    // Check on mount
    handleHashChange();

    // Listen for hash changes
    window.addEventListener("hashchange", handleHashChange);
    return () => window.removeEventListener("hashchange", handleHashChange);
  }, []);

  // Handle successful generation - switch to preview and show draft
  const handleGenerated = (response: GenerateRecipeResponse) => {
    setDraftRecipe(response.recipe);
    setActiveTab("preview");
    // Clear any selected recipe from list to show the new draft
    onRecipeGenerated?.();
  };

  // Handle successful save - could navigate to saved recipe
  const handleSaved = (summary: RecipeSummaryDTO) => {
    // Clear draft after save
    setDraftRecipe(undefined);
    // Could trigger navigation to /app/recipes/:id here
    console.log("Recipe saved:", summary.id);
  };

  // Handle delete - clear selection and stay on preview tab
  const handleDeleted = (id: string) => {
    // Stay on preview tab - it will show "No recipe selected" placeholder
    // Notify parent to clear selection
    onRecipeDeleted?.();
    // Navigate back to /app (clear recipe ID from URL)
    window.history.pushState({}, "", "/app");
  };

  // Restore draft from sessionStorage
  const handleRestoreDraft = () => {
    const stored = sessionStorage.getItem("generatorDraft");
    if (stored) {
      try {
        const draft = JSON.parse(stored);
        setDraftRecipe(draft.recipe);
      } catch (error) {
        console.error("Failed to restore draft:", error);
      }
    }
  };

  // Determine preview mode and data
  const previewMode = selectedRecipeId && selectedRecipe ? "saved" : "draft";
  const showDraft = !selectedRecipeId && draftRecipe;
  const showSaved = selectedRecipeId && selectedRecipe;

  return (
    <div className="h-full flex flex-col">
      <Tabs value={activeTab} onValueChange={(v) => setActiveTab(v as ActiveTab)} className="flex-1 flex flex-col">
        <TabsList className="w-full">
          <TabsTrigger value="generator" className="flex-1">
            Generator
          </TabsTrigger>
          <TabsTrigger value="preview" className="flex-1">
            Preview
            {(showDraft || showSaved) && (
              <span className="ml-2 h-2 w-2 rounded-full bg-primary" />
            )}
          </TabsTrigger>
        </TabsList>

        <TabsContent value="generator" className="flex-1 overflow-hidden mt-0">
          <div className="h-full overflow-y-auto">
            <GeneratorPanel onGenerated={handleGenerated} />
          </div>
        </TabsContent>

        <TabsContent value="preview" className="flex-1 overflow-hidden mt-0">
          <PreviewPanel
            mode={previewMode}
            recipe={showDraft ? draftRecipe : undefined}
            details={showSaved ? selectedRecipe : undefined}
            onSaved={handleSaved}
            onDeleted={handleDeleted}
            onTagClick={onTagClick}
            onRestoreDraft={handleRestoreDraft}
          />
        </TabsContent>
      </Tabs>
    </div>
  );
}



================================================
FILE: src/components/app/SaveButton.tsx
================================================
import { Button } from "@/components/ui/button";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { Save, ExternalLink } from "lucide-react";

interface SaveButtonProps {
  onClick: () => void;
  disabled: boolean;
  loading: boolean;
  disabledReason?: string;
}

/**
 * SaveButton component - saves recipe draft with validation
 * Shows tooltip with reason when disabled (e.g., disliked ingredients)
 * Links to profile page when blocked by preferences
 */
export function SaveButton({
  onClick,
  disabled,
  loading,
  disabledReason,
}: SaveButtonProps) {
  const button = (
    <Button
      onClick={onClick}
      disabled={disabled || loading}
      className="gap-2"
      size="lg"
    >
      <Save className="h-5 w-5" />
      {loading ? "Saving..." : "Save recipe"}
    </Button>
  );

  if (disabled && disabledReason) {
    return (
      <TooltipProvider>
        <div className="space-y-2">
          <Tooltip>
            <TooltipTrigger asChild>{button}</TooltipTrigger>
            <TooltipContent className="max-w-xs">
              <p>{disabledReason}</p>
            </TooltipContent>
          </Tooltip>
          {disabledReason.toLowerCase().includes("disliked") && (
            <a
              href="/profile"
              className="flex items-center gap-1 text-xs text-muted-foreground hover:text-foreground transition-colors"
            >
              <ExternalLink className="h-3 w-3" />
              Update dietary preferences
            </a>
          )}
        </div>
      </TooltipProvider>
    );
  }

  return button;
}



================================================
FILE: src/components/app/SearchBar.tsx
================================================
import { useState, useEffect, useCallback } from "react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Search, X } from "lucide-react";

interface SearchBarProps {
  value: string;
  onChange: (value: string) => void;
  onSubmit: () => void;
  disabled?: boolean;
  maxLength?: number;
}

/**
 * SearchBar component for full-text search
 * Supports debounced input, Enter key submission, and clear button
 */
export function SearchBar({
  value,
  onChange,
  onSubmit,
  disabled = false,
  maxLength = 200,
}: SearchBarProps) {
  const [inputValue, setInputValue] = useState(value);

  // Sync with external value changes
  useEffect(() => {
    setInputValue(value);
  }, [value]);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value;
    if (newValue.length <= maxLength) {
      setInputValue(newValue);
    }
  };

  const handleSubmit = useCallback(() => {
    const trimmed = inputValue.trim();
    if (trimmed !== value) {
      onChange(trimmed);
      onSubmit();
    }
  }, [inputValue, value, onChange, onSubmit]);

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter") {
      e.preventDefault();
      handleSubmit();
    }
  };

  const handleClear = () => {
    setInputValue("");
    onChange("");
    onSubmit();
  };

  const showClearButton = inputValue.length > 0;

  return (
    <div className="flex gap-2" role="search">
      <div className="relative flex-1">
        <Input
          type="search"
          placeholder="Search recipes..."
          value={inputValue}
          onChange={handleChange}
          onKeyDown={handleKeyDown}
          disabled={disabled}
          maxLength={maxLength}
          className="pr-8"
          aria-label="Search recipes"
        />
        {showClearButton && !disabled && (
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={handleClear}
            className="absolute right-0 top-0 h-full px-2 hover:bg-transparent"
            aria-label="Clear search"
          >
            <X className="h-4 w-4" />
          </Button>
        )}
      </div>
      <Button
        type="button"
        onClick={handleSubmit}
        disabled={disabled || inputValue.trim().length === 0}
        aria-label="Search"
      >
        <Search className="h-4 w-4 mr-2" />
        Search
      </Button>
    </div>
  );
}



================================================
FILE: src/components/app/SortSelect.tsx
================================================
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import type { RecipeSortOrder } from "@/types";

interface SortSelectProps {
  value: RecipeSortOrder;
  onChange: (value: RecipeSortOrder) => void;
}

const SORT_OPTIONS = [
  { value: "recent" as const, label: "Recently added" },
  { value: "oldest" as const, label: "Oldest first" },
];

/**
 * SortSelect component for choosing recipe sort order
 * Defaults to "recent" (most recently added)
 */
export function SortSelect({ value, onChange }: SortSelectProps) {
  return (
    <div className="flex items-center gap-2">
      <label htmlFor="sort-select" className="text-sm font-medium">
        Sort by:
      </label>
      <Select value={value} onValueChange={onChange}>
        <SelectTrigger id="sort-select" className="w-[180px]">
          <SelectValue placeholder="Select sorting" />
        </SelectTrigger>
        <SelectContent>
          {SORT_OPTIONS.map((option) => (
            <SelectItem key={option.value} value={option.value}>
              {option.label}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
}



================================================
FILE: src/components/app/TagFilterChips.tsx
================================================
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { X, ChevronDown, ChevronUp } from "lucide-react";

interface TagFilterChipsProps {
  selected: string[];
  allTags: string[];
  onChange: (tags: string[]) => void;
}

const INITIAL_TAGS_LIMIT = 12;

/**
 * TagFilterChips component for OR-based tag filtering
 * Displays available tags as toggleable chips
 * Shows clear button when filters are active
 * Collapses to show only first 12 tags with "Show more" button
 */
export function TagFilterChips({ selected, allTags, onChange }: TagFilterChipsProps) {
  const [showAllTags, setShowAllTags] = useState(false);

  const handleToggle = (tag: string) => {
    const normalized = tag.toLowerCase();
    const isSelected = selected.includes(normalized);

    if (isSelected) {
      onChange(selected.filter((t) => t !== normalized));
    } else {
      onChange([...selected, normalized]);
    }
  };

  const handleClearAll = () => {
    onChange([]);
  };

  if (allTags.length === 0) {
    return null;
  }

  const hasSelectedTags = selected.length > 0;
  const hasMoreTags = allTags.length > INITIAL_TAGS_LIMIT;

  // Ensure selected tags are always visible
  // Show first N tags + any selected tags not in first N
  const visibleTags = showAllTags
    ? allTags
    : (() => {
        const initialTags = allTags.slice(0, INITIAL_TAGS_LIMIT);
        const selectedNotInInitial = allTags
          .slice(INITIAL_TAGS_LIMIT)
          .filter((tag) => selected.includes(tag.toLowerCase()));

        // Combine and deduplicate
        const combined = [...initialTags, ...selectedNotInInitial];
        return Array.from(new Set(combined));
      })();

  const hiddenCount = allTags.length - INITIAL_TAGS_LIMIT;

  return (
    <div className="space-y-2">
      <div className="flex items-center justify-between">
        <label className="text-sm font-medium">Tag filters:</label>
        {hasSelectedTags && (
          <Button
            variant="ghost"
            size="sm"
            onClick={handleClearAll}
            className="h-auto py-1 px-2 text-xs"
            aria-label="Clear all filters"
          >
            Clear filters
          </Button>
        )}
      </div>
      <div className="flex flex-wrap gap-2" role="group" aria-label="Tag filters">
        {visibleTags.map((tag) => {
          const normalized = tag.toLowerCase();
          const isSelected = selected.includes(normalized);

          return (
            <Button
              key={normalized}
              variant={isSelected ? "default" : "outline"}
              size="sm"
              onClick={() => handleToggle(tag)}
              role="checkbox"
              aria-checked={isSelected}
              className="h-auto py-1 px-3"
            >
              {tag}
              {isSelected && <X className="ml-1 h-3 w-3" />}
            </Button>
          );
        })}
      </div>

      {/* Show more/less button */}
      {hasMoreTags && (
        <div className="flex justify-center pt-1">
          <Button
            variant="ghost"
            size="sm"
            onClick={() => setShowAllTags(!showAllTags)}
            className="h-auto py-1 px-3 text-xs text-muted-foreground hover:text-foreground"
          >
            {showAllTags ? (
              <>
                <ChevronUp className="mr-1 h-3 w-3" />
                Show less
              </>
            ) : (
              <>
                <ChevronDown className="mr-1 h-3 w-3" />
                Show more ({hiddenCount} more)
              </>
            )}
          </Button>
        </div>
      )}

      {hasSelectedTags && (
        <div className="text-xs text-muted-foreground" aria-live="polite">
          {selected.length} {selected.length === 1 ? "tag" : "tags"} selected
        </div>
      )}
    </div>
  );
}



================================================
FILE: src/components/app/TextareaWithCounter.tsx
================================================
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";

interface TextareaWithCounterProps {
  value: string;
  onChange: (value: string) => void;
  disabled?: boolean;
  maxLength?: number;
  label?: string;
  placeholder?: string;
}

/**
 * TextareaWithCounter component - textarea with character counter
 * Used for recipe generation prompt input
 */
export function TextareaWithCounter({
  value,
  onChange,
  disabled = false,
  maxLength = 2000,
  label = "Recipe generation prompt",
  placeholder = "Describe the recipe you want to generate...",
}: TextareaWithCounterProps) {
  const remaining = maxLength - value.length;
  const isNearLimit = remaining < 100;
  const isAtLimit = remaining === 0;

  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    const newValue = e.target.value;
    if (newValue.length <= maxLength) {
      onChange(newValue);
    }
  };

  return (
    <div className="space-y-2">
      <Label htmlFor="recipe-prompt">{label}</Label>
      <Textarea
        id="recipe-prompt"
        value={value}
        onChange={handleChange}
        disabled={disabled}
        placeholder={placeholder}
        className="min-h-[200px] resize-none"
        maxLength={maxLength}
        aria-describedby="prompt-counter"
      />
      <div
        id="prompt-counter"
        className={`text-xs text-right ${
          isAtLimit
            ? "text-destructive font-semibold"
            : isNearLimit
              ? "text-yellow-600 dark:text-yellow-500"
              : "text-muted-foreground"
        }`}
        aria-live="polite"
      >
        {value.length} / {maxLength} characters
        {isAtLimit && " (limit reached)"}
      </div>
    </div>
  );
}



================================================
FILE: src/components/auth/AuthForm.tsx
================================================
import { useState, useRef } from "react";
import type { FormEvent } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "../ui/card";
import { Button } from "../ui/button";
import { Alert, AlertDescription } from "../ui/alert";
import { AlertCircle } from "lucide-react";
import { EmailInput } from "./EmailInput";
import { PasswordInput } from "./PasswordInput";
import { validateAuthForm, hasErrors, normalizeEmail } from "../../lib/auth/validation";
import { sendSessionStartEvent } from "../../lib/auth/telemetry";
import type { AuthFormMode, AuthFormValues, AuthFormErrors } from "../../lib/auth/types";
import { supabaseClient } from "../../db/supabase.client";

interface AuthFormProps {
  /** Initial mode - login or register */
  initialMode?: AuthFormMode;
}

/**
 * AuthForm Component
 *
 * Dual-mode authentication form for login and registration.
 * Currently UI-only, ready for backend integration.
 *
 * Features:
 * - Login/Register mode switching
 * - Client-side validation (email format, password length)
 * - Error display (inline and global)
 * - Focus management
 * - Full ARIA support
 * - Loading states
 * - Placeholder for future Supabase Auth integration
 *
 * @component
 */
export function AuthForm({ initialMode = "login" }: AuthFormProps) {
  const [mode, setMode] = useState<AuthFormMode>(initialMode);
  const [values, setValues] = useState<AuthFormValues>({
    email: "",
    password: "",
  });
  const [errors, setErrors] = useState<AuthFormErrors>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [touched, setTouched] = useState<{ email: boolean; password: boolean }>({
    email: false,
    password: false,
  });

  // Refs for focus management
  const emailRef = useRef<HTMLInputElement>(null);
  const passwordRef = useRef<HTMLInputElement>(null);

  // Handle email change
  const handleEmailChange = (email: string) => {
    setValues((prev) => ({ ...prev, email }));
    if (touched.email) {
      // Clear error on change if field was touched
      setErrors((prev) => ({ ...prev, email: undefined }));
    }
  };

  // Handle password change
  const handlePasswordChange = (password: string) => {
    setValues((prev) => ({ ...prev, password }));
    if (touched.password) {
      // Clear error on change if field was touched
      setErrors((prev) => ({ ...prev, password: undefined }));
    }
  };

  // Handle email blur (validation trigger)
  const handleEmailBlur = () => {
    setTouched((prev) => ({ ...prev, email: true }));
    const emailError = validateAuthForm({ ...values }).email;
    setErrors((prev) => ({ ...prev, email: emailError }));
  };

  // Handle password blur (validation trigger)
  const handlePasswordBlur = () => {
    setTouched((prev) => ({ ...prev, password: true }));
    const passwordError = validateAuthForm({ ...values }).password;
    setErrors((prev) => ({ ...prev, password: passwordError }));
  };

  // Handle form submission
  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    console.log("[AuthForm] Submit started, mode:", mode);

    // Mark all fields as touched
    setTouched({ email: true, password: true });

    // Validate form
    const validationErrors = validateAuthForm(values);
    setErrors(validationErrors);
    console.log("[AuthForm] Validation errors:", validationErrors);

    if (hasErrors(validationErrors)) {
      console.log("[AuthForm] Validation failed, stopping");
      // Focus first error field
      if (validationErrors.email) {
        emailRef.current?.focus();
      } else if (validationErrors.password) {
        passwordRef.current?.focus();
      }
      return;
    }

    setIsSubmitting(true);
    console.log("[AuthForm] Starting auth request...");

    // Normalize email
    const normalizedEmail = normalizeEmail(values.email);
    console.log("[AuthForm] Normalized email:", normalizedEmail);

    try {
      // Use Supabase Auth SDK directly (client-side auth per auth-spec.md)
      if (mode === "login") {
        console.log("[AuthForm] Calling signInWithPassword...");
        const { data, error } = await supabaseClient.auth.signInWithPassword({
          email: normalizedEmail,
          password: values.password,
        });

        console.log("[AuthForm] signInWithPassword response:", { data: !!data, error: error?.message });

        if (error) {
          // Map Supabase errors to user-friendly messages
          let message = "Login failed";

          if (error.message.includes("Invalid login credentials")) {
            message = "Invalid email or password";
          } else if (error.message.includes("Email not confirmed")) {
            message = "Please verify your email address";
          } else if (error.message.includes("rate")) {
            message = "Too many attempts. Please try again later";
          }

          console.log("[AuthForm] Login error:", message);
          setErrors({ form: message });
          return;
        }

        console.log("[AuthForm] Login successful, waiting for session...");
        // Wait for session to be saved to localStorage (prevent race condition)
        await new Promise(resolve => setTimeout(resolve, 100));

        // Verify session is available
        const { data: sessionData } = await supabaseClient.auth.getSession();
        console.log("[AuthForm] Session check:", { hasSession: !!sessionData.session });
        if (!sessionData.session) {
          console.log("[AuthForm] Session not available!");
          setErrors({ form: "Session error. Please try again." });
          return;
        }

        // Send session_start telemetry event (best-effort, non-blocking)
        console.log("[AuthForm] Sending telemetry...");
        sendSessionStartEvent().catch(() => {
          // Ignore telemetry errors - don't block UX
        });

        // Redirect to /app on successful login
        console.log("[AuthForm] Redirecting to /app");
        window.location.href = "/app";
      } else {
        const { data, error } = await supabaseClient.auth.signUp({
          email: normalizedEmail,
          password: values.password,
        });

        if (error) {
          setErrors({ form: error.message || "Registration failed" });
          return;
        }

        // Wait for session to be saved to localStorage (prevent race condition)
        await new Promise(resolve => setTimeout(resolve, 100));

        // Verify session is available
        const { data: sessionData } = await supabaseClient.auth.getSession();
        if (!sessionData.session) {
          setErrors({ form: "Session error. Please try again." });
          return;
        }

        // Send session_start telemetry event (best-effort, non-blocking)
        sendSessionStartEvent().catch(() => {
          // Ignore telemetry errors - don't block UX
        });

        // Redirect to /app on successful registration
        window.location.href = "/app";
      }
    } catch (error) {
      console.error("[AuthForm] Caught error:", error);
      setErrors({
        form: "Network error. Please check your connection and try again.",
      });
    } finally {
      console.log("[AuthForm] Submit finished");
      setIsSubmitting(false);
    }
  };

  // Handle mode switch
  const handleModeSwitch = () => {
    setMode((prev) => (prev === "login" ? "register" : "login"));
    // Clear errors when switching modes
    setErrors({});
    // Optionally preserve email value
  };

  const isLogin = mode === "login";
  const isValid = !hasErrors(errors);

  return (
    <Card className="w-full max-w-md mx-auto">
      <CardHeader>
        <CardTitle>{isLogin ? "Sign In" : "Create Account"}</CardTitle>
        <CardDescription>
          {isLogin
            ? "Enter your email and password to sign in"
            : "Enter your email and password to create an account"}
        </CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit} className="space-y-4" aria-label={`${isLogin ? "Login" : "Registration"} form`}>
          {/* Global form error */}
          {errors.form && (
            <Alert variant={errors.form.includes("ready") ? "default" : "destructive"}>
              <AlertCircle className="h-4 w-4" />
              <AlertDescription>{errors.form}</AlertDescription>
            </Alert>
          )}

          {/* Email input */}
          <EmailInput
            ref={emailRef}
            value={values.email}
            onChange={handleEmailChange}
            onBlur={handleEmailBlur}
            error={touched.email ? errors.email : undefined}
            disabled={isSubmitting}
          />

          {/* Password input */}
          <PasswordInput
            ref={passwordRef}
            value={values.password}
            onChange={handlePasswordChange}
            onBlur={handlePasswordBlur}
            error={touched.password ? errors.password : undefined}
            disabled={isSubmitting}
            label={isLogin ? "Password" : "Password (min. 8 characters)"}
          />

          {/* Submit button */}
          <Button
            type="submit"
            className="w-full"
            disabled={isSubmitting || !isValid}
            aria-label={isLogin ? "Sign in" : "Create account"}
          >
            {isSubmitting ? "Processing..." : isLogin ? "Sign In" : "Create Account"}
          </Button>

          {/* Forgot password link - only show in login mode */}
          {isLogin && (
            <div className="text-center text-sm">
              <a
                href="/auth/forgot"
                className="text-muted-foreground hover:text-primary hover:underline"
              >
                Forgot your password?
              </a>
            </div>
          )}

          {/* Mode switch link */}
          <div className="text-center text-sm">
            {isLogin ? (
              <p>
                Don't have an account?{" "}
                <button
                  type="button"
                  onClick={handleModeSwitch}
                  className="text-primary hover:underline font-medium"
                  disabled={isSubmitting}
                >
                  Sign up
                </button>
              </p>
            ) : (
              <p>
                Already have an account?{" "}
                <button
                  type="button"
                  onClick={handleModeSwitch}
                  className="text-primary hover:underline font-medium"
                  disabled={isSubmitting}
                >
                  Sign in
                </button>
              </p>
            )}
          </div>
        </form>
      </CardContent>
    </Card>
  );
}



================================================
FILE: src/components/auth/EmailInput.tsx
================================================
import { forwardRef } from "react";
import { Input } from "../ui/input";
import { Label } from "../ui/label";

interface EmailInputProps {
  /** Current email value */
  value: string;
  /** Change handler */
  onChange: (value: string) => void;
  /** Validation error message */
  error?: string;
  /** Disabled state */
  disabled?: boolean;
  /** Blur handler for validation trigger */
  onBlur?: () => void;
}

/**
 * EmailInput Component
 *
 * Email input field with label and error display.
 * Supports validation and accessibility features.
 *
 * Features:
 * - Auto-complete for email
 * - ARIA error handling
 * - Focus management
 * - Disabled state support
 *
 * @component
 */
export const EmailInput = forwardRef<HTMLInputElement, EmailInputProps>(
  ({ value, onChange, error, disabled, onBlur }, ref) => {
    const hasError = !!error;

    return (
      <div className="space-y-2">
        <Label htmlFor="email">Email</Label>
        <Input
          ref={ref}
          id="email"
          type="email"
          autoComplete="email"
          value={value}
          onChange={(e) => onChange(e.target.value)}
          onBlur={onBlur}
          disabled={disabled}
          aria-invalid={hasError}
          aria-describedby={hasError ? "email-error" : undefined}
          className={hasError ? "border-destructive" : ""}
        />
        {hasError && (
          <p id="email-error" className="text-sm text-destructive" role="alert">
            {error}
          </p>
        )}
      </div>
    );
  }
);

EmailInput.displayName = "EmailInput";



================================================
FILE: src/components/auth/ForgotPasswordForm.tsx
================================================
import { useState, useRef } from "react";
import type { FormEvent } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "../ui/card";
import { Button } from "../ui/button";
import { Alert, AlertDescription } from "../ui/alert";
import { AlertCircle, CheckCircle } from "lucide-react";
import { EmailInput } from "./EmailInput";
import { validateEmail, normalizeEmail } from "../../lib/auth/validation";
import { supabaseClient } from "../../db/supabase.client";

/**
 * ForgotPasswordForm Component
 *
 * Form for requesting a password reset email.
 *
 * Features:
 * - Email validation
 * - Calls Supabase resetPasswordForEmail
 * - Shows success message without revealing if account exists
 * - Error handling
 * - Full accessibility
 *
 * @component
 */
export function ForgotPasswordForm() {
  const [email, setEmail] = useState("");
  const [emailError, setEmailError] = useState<string | undefined>();
  const [formError, setFormError] = useState<string | undefined>();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isSuccess, setIsSuccess] = useState(false);
  const [touched, setTouched] = useState(false);

  const emailRef = useRef<HTMLInputElement>(null);

  const handleEmailChange = (value: string) => {
    setEmail(value);
    if (touched) {
      setEmailError(undefined);
    }
  };

  const handleEmailBlur = () => {
    setTouched(true);
    const error = validateEmail(email);
    setEmailError(error);
  };

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();

    // Mark as touched
    setTouched(true);

    // Validate email
    const error = validateEmail(email);
    setEmailError(error);

    if (error) {
      emailRef.current?.focus();
      return;
    }

    setIsSubmitting(true);
    setFormError(undefined);

    const normalizedEmail = normalizeEmail(email);

    try {
      // Request password reset email
      const { error } = await supabaseClient.auth.resetPasswordForEmail(normalizedEmail, {
        redirectTo: `${window.location.origin}/auth/reset`,
      });

      if (error) {
        console.error("Password reset error:", error);
        setFormError("Failed to send reset email. Please try again.");
        setIsSubmitting(false);
        return;
      }

      // Show success message (don't reveal if account exists)
      setIsSuccess(true);
    } catch (error) {
      console.error("Unexpected error:", error);
      setFormError("An unexpected error occurred. Please try again.");
      setIsSubmitting(false);
    }
  };

  if (isSuccess) {
    return (
      <Card className="w-full max-w-md mx-auto">
        <CardHeader>
          <CardTitle>Check your email</CardTitle>
          <CardDescription>
            If an account exists with this email, you will receive password reset instructions.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Alert>
            <CheckCircle className="h-4 w-4" />
            <AlertDescription>
              We've sent password reset instructions to <strong>{email}</strong>.
              Please check your inbox and spam folder.
            </AlertDescription>
          </Alert>

          <div className="mt-6 text-center">
            <Button variant="ghost" size="sm" asChild>
              <a href="/login">Back to Sign In</a>
            </Button>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="w-full max-w-md mx-auto">
      <CardHeader>
        <CardTitle>Forgot your password?</CardTitle>
        <CardDescription>
          Enter your email address and we'll send you instructions to reset your password.
        </CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit} className="space-y-4" aria-label="Forgot password form">
          {/* Form error */}
          {formError && (
            <Alert variant="destructive">
              <AlertCircle className="h-4 w-4" />
              <AlertDescription>{formError}</AlertDescription>
            </Alert>
          )}

          {/* Email input */}
          <EmailInput
            ref={emailRef}
            value={email}
            onChange={handleEmailChange}
            onBlur={handleEmailBlur}
            error={touched ? emailError : undefined}
            disabled={isSubmitting}
          />

          {/* Submit button */}
          <Button
            type="submit"
            className="w-full"
            disabled={isSubmitting || !!emailError}
            aria-label="Send reset instructions"
          >
            {isSubmitting ? "Sending..." : "Send Reset Instructions"}
          </Button>

          {/* Back to login link */}
          <div className="text-center text-sm">
            <p>
              Remember your password?{" "}
              <a
                href="/login"
                className="text-primary hover:underline font-medium"
              >
                Sign in
              </a>
            </p>
          </div>
        </form>
      </CardContent>
    </Card>
  );
}



================================================
FILE: src/components/auth/PasswordInput.tsx
================================================
import { forwardRef, useState } from "react";
import { Input } from "../ui/input";
import { Label } from "../ui/label";
import { Button } from "../ui/button";
import { Eye, EyeOff } from "lucide-react";

interface PasswordInputProps {
  /** Current password value */
  value: string;
  /** Change handler */
  onChange: (value: string) => void;
  /** Validation error message */
  error?: string;
  /** Disabled state */
  disabled?: boolean;
  /** Blur handler for validation trigger */
  onBlur?: () => void;
  /** Label text (default: "Password") */
  label?: string;
}

/**
 * PasswordInput Component
 *
 * Password input field with show/hide toggle, label, and error display.
 * Supports validation and accessibility features.
 *
 * Features:
 * - Show/hide password toggle
 * - ARIA error handling
 * - Focus management
 * - Auto-complete support
 * - Disabled state support
 *
 * @component
 */
export const PasswordInput = forwardRef<HTMLInputElement, PasswordInputProps>(
  ({ value, onChange, error, disabled, onBlur, label = "Password" }, ref) => {
    const [showPassword, setShowPassword] = useState(false);
    const hasError = !!error;

    const toggleShowPassword = () => {
      setShowPassword((prev) => !prev);
    };

    return (
      <div className="space-y-2">
        <Label htmlFor="password">{label}</Label>
        <div className="relative">
          <Input
            ref={ref}
            id="password"
            type={showPassword ? "text" : "password"}
            autoComplete="current-password"
            value={value}
            onChange={(e) => onChange(e.target.value)}
            onBlur={onBlur}
            disabled={disabled}
            aria-invalid={hasError}
            aria-describedby={hasError ? "password-error" : undefined}
            className={`pr-10 ${hasError ? "border-destructive" : ""}`}
          />
          <Button
            type="button"
            variant="ghost"
            size="sm"
            className="absolute right-0 top-0 h-full px-3 py-2 hover:bg-transparent"
            onClick={toggleShowPassword}
            disabled={disabled}
            aria-label={showPassword ? "Hide password" : "Show password"}
          >
            {showPassword ? (
              <EyeOff className="h-4 w-4 text-muted-foreground" aria-hidden="true" />
            ) : (
              <Eye className="h-4 w-4 text-muted-foreground" aria-hidden="true" />
            )}
          </Button>
        </div>
        {hasError && (
          <p id="password-error" className="text-sm text-destructive" role="alert">
            {error}
          </p>
        )}
      </div>
    );
  }
);

PasswordInput.displayName = "PasswordInput";



================================================
FILE: src/components/auth/ResetPasswordForm.tsx
================================================
import { useState, useRef, useEffect } from "react";
import type { FormEvent } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "../ui/card";
import { Button } from "../ui/button";
import { Alert, AlertDescription } from "../ui/alert";
import { AlertCircle, CheckCircle } from "lucide-react";
import { PasswordInput } from "./PasswordInput";
import { validatePassword } from "../../lib/auth/validation";
import { supabaseClient } from "../../db/supabase.client";

/**
 * ResetPasswordForm Component
 *
 * Form for setting a new password after clicking reset link.
 * Detects PASSWORD_RECOVERY state from Supabase.
 *
 * Features:
 * - Detects password recovery session
 * - Password validation
 * - Calls Supabase updateUser
 * - Shows success/error states
 * - Full accessibility
 *
 * @component
 */
export function ResetPasswordForm() {
  const [password, setPassword] = useState("");
  const [passwordError, setPasswordError] = useState<string | undefined>();
  const [formError, setFormError] = useState<string | undefined>();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isSuccess, setIsSuccess] = useState(false);
  const [isRecoverySession, setIsRecoverySession] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [touched, setTouched] = useState(false);

  const passwordRef = useRef<HTMLInputElement>(null);

  // Check for password recovery session on mount
  useEffect(() => {
    const checkRecoverySession = async () => {
      try {
        const { data: { session } } = await supabaseClient.auth.getSession();

        // Check if this is a password recovery session
        if (session) {
          setIsRecoverySession(true);
        } else {
          setFormError("Invalid or expired password reset link.");
        }
      } catch (error) {
        console.error("Failed to check recovery session:", error);
        setFormError("Failed to verify reset link. Please try again.");
      } finally {
        setIsLoading(false);
      }
    };

    checkRecoverySession();

    // Subscribe to auth state changes
    const { data: { subscription } } = supabaseClient.auth.onAuthStateChange((event, session) => {
      if (event === "PASSWORD_RECOVERY") {
        setIsRecoverySession(true);
        setIsLoading(false);
      }
    });

    return () => subscription.unsubscribe();
  }, []);

  const handlePasswordChange = (value: string) => {
    setPassword(value);
    if (touched) {
      setPasswordError(undefined);
    }
  };

  const handlePasswordBlur = () => {
    setTouched(true);
    const error = validatePassword(password);
    setPasswordError(error);
  };

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();

    // Mark as touched
    setTouched(true);

    // Validate password
    const error = validatePassword(password);
    setPasswordError(error);

    if (error) {
      passwordRef.current?.focus();
      return;
    }

    setIsSubmitting(true);
    setFormError(undefined);

    try {
      // Update user password
      const { error } = await supabaseClient.auth.updateUser({ password });

      if (error) {
        console.error("Password update error:", error);
        setFormError("Failed to update password. Please try again.");
        setIsSubmitting(false);
        return;
      }

      // Success
      setIsSuccess(true);

      // Redirect to login after 3 seconds
      setTimeout(() => {
        window.location.href = "/login";
      }, 3000);
    } catch (error) {
      console.error("Unexpected error:", error);
      setFormError("An unexpected error occurred. Please try again.");
      setIsSubmitting(false);
    }
  };

  // Loading state
  if (isLoading) {
    return (
      <Card className="w-full max-w-md mx-auto">
        <CardHeader>
          <CardTitle>Reset your password</CardTitle>
          <CardDescription>Verifying reset link...</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="flex items-center justify-center py-8">
            <div className="text-muted-foreground">Loading...</div>
          </div>
        </CardContent>
      </Card>
    );
  }

  // Success state
  if (isSuccess) {
    return (
      <Card className="w-full max-w-md mx-auto">
        <CardHeader>
          <CardTitle>Password updated!</CardTitle>
          <CardDescription>Your password has been successfully reset.</CardDescription>
        </CardHeader>
        <CardContent>
          <Alert>
            <CheckCircle className="h-4 w-4" />
            <AlertDescription>
              You can now sign in with your new password. Redirecting to login page...
            </AlertDescription>
          </Alert>

          <div className="mt-6 text-center">
            <Button variant="ghost" size="sm" asChild>
              <a href="/login">Go to Sign In</a>
            </Button>
          </div>
        </CardContent>
      </Card>
    );
  }

  // Error state (invalid/expired link)
  if (!isRecoverySession) {
    return (
      <Card className="w-full max-w-md mx-auto">
        <CardHeader>
          <CardTitle>Reset link expired</CardTitle>
          <CardDescription>This password reset link is invalid or has expired.</CardDescription>
        </CardHeader>
        <CardContent>
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>{formError || "Invalid reset link."}</AlertDescription>
          </Alert>

          <div className="mt-6 text-center">
            <Button variant="default" asChild>
              <a href="/auth/forgot">Request New Reset Link</a>
            </Button>
          </div>
        </CardContent>
      </Card>
    );
  }

  // Form state
  return (
    <Card className="w-full max-w-md mx-auto">
      <CardHeader>
        <CardTitle>Set new password</CardTitle>
        <CardDescription>
          Enter a new password for your account. Make sure it's at least 8 characters long.
        </CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit} className="space-y-4" aria-label="Reset password form">
          {/* Form error */}
          {formError && (
            <Alert variant="destructive">
              <AlertCircle className="h-4 w-4" />
              <AlertDescription>{formError}</AlertDescription>
            </Alert>
          )}

          {/* Password input */}
          <PasswordInput
            ref={passwordRef}
            value={password}
            onChange={handlePasswordChange}
            onBlur={handlePasswordBlur}
            error={touched ? passwordError : undefined}
            disabled={isSubmitting}
            label="New Password (min. 8 characters)"
          />

          {/* Submit button */}
          <Button
            type="submit"
            className="w-full"
            disabled={isSubmitting || !!passwordError}
            aria-label="Update password"
          >
            {isSubmitting ? "Updating..." : "Update Password"}
          </Button>

          {/* Back to login link */}
          <div className="text-center text-sm">
            <p>
              Remember your password?{" "}
              <a
                href="/login"
                className="text-primary hover:underline font-medium"
              >
                Sign in
              </a>
            </p>
          </div>
        </form>
      </CardContent>
    </Card>
  );
}



================================================
FILE: src/components/auth/UserMenu.tsx
================================================
import { useState } from "react";
import { User, LogOut, UserCircle } from "lucide-react";
import { Button } from "../ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "../ui/dropdown-menu";
import { clearSessionStartTracking } from "../../lib/auth/telemetry";

interface UserMenuProps {
  /** User email to display */
  email: string;
}

/**
 * UserMenu Component
 *
 * Dropdown menu for authenticated users with logout functionality.
 *
 * Features:
 * - Display user email
 * - Logout button with API call
 * - Loading state during logout
 * - Error handling
 *
 * @component
 */
export function UserMenu({ email }: UserMenuProps) {
  const [isLoggingOut, setIsLoggingOut] = useState(false);

  const handleLogout = async () => {
    setIsLoggingOut(true);

    try {
      const response = await fetch("/api/auth/logout", {
        method: "POST",
      });

      if (!response.ok) {
        throw new Error("Logout failed");
      }

      // Clear session_start tracking for next login
      clearSessionStartTracking();

      // Redirect to login page
      window.location.href = "/login";
    } catch (error) {
      console.error("Logout error:", error);
      setIsLoggingOut(false);
      // Show error to user (could use toast here)
      alert("Failed to logout. Please try again.");
    }
  };

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button
          variant="ghost"
          size="sm"
          className="flex items-center space-x-2"
          disabled={isLoggingOut}
        >
          <User className="h-4 w-4" />
          <span className="text-sm max-w-[150px] truncate hidden sm:inline">
            {email}
          </span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-56">
        <DropdownMenuLabel>
          <div className="flex flex-col space-y-1">
            <p className="text-sm font-medium leading-none">Account</p>
            <p className="text-xs leading-none text-muted-foreground truncate">
              {email}
            </p>
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuItem asChild className="cursor-pointer">
          <a href="/profile" className="flex items-center">
            <UserCircle className="mr-2 h-4 w-4" />
            <span>Profile</span>
          </a>
        </DropdownMenuItem>
        <DropdownMenuItem
          onClick={handleLogout}
          disabled={isLoggingOut}
          className="cursor-pointer text-destructive focus:text-destructive"
        >
          <LogOut className="mr-2 h-4 w-4" />
          <span>{isLoggingOut ? "Signing out..." : "Sign out"}</span>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}



================================================
FILE: src/components/profile/DietTypeSelect.tsx
================================================
import { forwardRef } from "react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "../ui/select";
import type { DietType } from "../../types";

const DIET_TYPES: { value: DietType; label: string }[] = [
  { value: "vegan", label: "Vegan" },
  { value: "vegetarian", label: "Vegetarian" },
  { value: "pescatarian", label: "Pescatarian" },
  { value: "keto", label: "Keto" },
  { value: "paleo", label: "Paleo" },
  { value: "gluten_free", label: "Gluten Free" },
  { value: "dairy_free", label: "Dairy Free" },
  { value: "low_carb", label: "Low Carb" },
  { value: "mediterranean", label: "Mediterranean" },
  { value: "omnivore", label: "Omnivore" },
];

interface DietTypeSelectProps {
  /** Current selected diet type (null = none) */
  value: DietType | null;
  /** Change handler - receives DietType or null */
  onChange: (value: DietType | null) => void;
  /** ARIA invalid state for accessibility */
  "aria-invalid"?: boolean;
  /** ARIA describedby ID for error/helper text */
  "aria-describedby"?: string;
}

/**
 * DietTypeSelect Component
 *
 * Select dropdown for choosing dietary preference type.
 * Includes all DietType enum values plus a "None" option to clear.
 *
 * Features:
 * - All diet types from enum (vegan, vegetarian, etc.)
 * - "None" option to clear selection (sets null)
 * - Full ARIA support
 * - Keyboard navigation support
 *
 * @component
 */
export const DietTypeSelect = forwardRef<HTMLButtonElement, DietTypeSelectProps>(
  ({ value, onChange, "aria-invalid": ariaInvalid, "aria-describedby": ariaDescribedBy }, ref) => {
    const handleValueChange = (newValue: string) => {
      if (newValue === "none") {
        onChange(null);
      } else {
        onChange(newValue as DietType);
      }
    };

    return (
      <Select value={value || "none"} onValueChange={handleValueChange}>
        <SelectTrigger
          id="dietType"
          className="w-full"
          ref={ref}
          aria-invalid={ariaInvalid}
          aria-describedby={ariaDescribedBy}
        >
          <SelectValue placeholder="Select a diet type" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="none">None</SelectItem>
          {DIET_TYPES.map((diet) => (
            <SelectItem key={diet.value} value={diet.value}>
              {diet.label}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    );
  }
);

DietTypeSelect.displayName = "DietTypeSelect";



================================================
FILE: src/components/profile/TagsInput.tsx
================================================
import { useState, forwardRef } from "react";
import type { KeyboardEvent } from "react";
import { Input } from "../ui/input";
import { Badge } from "../ui/badge";
import { X } from "lucide-react";

interface TagsInputProps {
  /** Field name - used for ID and ARIA labels */
  name: "dislikedIngredients" | "preferredCuisines";
  /** Current tag values (normalized strings) */
  value: string[];
  /** Change handler - receives normalized array */
  onChange: (value: string[]) => void;
  /** Input placeholder text */
  placeholder?: string;
  /** ARIA invalid state for accessibility */
  "aria-invalid"?: boolean;
  /** ARIA describedby ID for error/helper text */
  "aria-describedby"?: string;
}

/**
 * TagsInput Component
 *
 * Input field for managing string arrays as tags/chips.
 * Supports keyboard navigation and auto-normalization.
 *
 * Features:
 * - Add tags with Enter or comma
 * - Remove tags with X button or Backspace on empty input
 * - Auto-normalization (lowercase, trim, dedupe)
 * - Max 100 items, max 50 chars per item
 * - Live counter display
 * - Full ARIA support
 *
 * @component
 */
export const TagsInput = forwardRef<HTMLInputElement, TagsInputProps>(
  ({ name, value, onChange, placeholder, "aria-invalid": ariaInvalid, "aria-describedby": ariaDescribedBy }, ref) => {
  const [inputValue, setInputValue] = useState("");

  // Add a new tag
  const addTag = (tag: string) => {
    const trimmed = tag.trim();
    if (trimmed.length === 0) return;
    if (trimmed.length > 50) return; // Max length validation

    // Check if tag already exists (case-insensitive)
    const normalized = trimmed.toLowerCase();
    if (value.some((existing) => existing.toLowerCase() === normalized)) {
      setInputValue(""); // Clear input but don't add duplicate
      return;
    }

    // Add the tag
    onChange([...value, normalized]);
    setInputValue("");
  };

  // Remove a tag by index
  const removeTag = (index: number) => {
    onChange(value.filter((_, i) => i !== index));
  };

  // Handle keyboard events
  const handleKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter" || e.key === ",") {
      e.preventDefault();
      addTag(inputValue);
    } else if (e.key === "Backspace" && inputValue === "" && value.length > 0) {
      // Remove last tag when backspace is pressed on empty input
      removeTag(value.length - 1);
    }
  };

  // Handle blur (add tag when user leaves input)
  const handleBlur = () => {
    if (inputValue.trim()) {
      addTag(inputValue);
    }
  };

    const maxReached = value.length >= 100;

    return (
      <div className="space-y-2">
        {/* Input field */}
        <Input
          id={name}
          type="text"
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          onKeyDown={handleKeyDown}
          onBlur={handleBlur}
          placeholder={maxReached ? "Maximum limit reached" : placeholder}
          disabled={maxReached}
          className="w-full"
          ref={ref}
          aria-invalid={ariaInvalid}
          aria-describedby={ariaDescribedBy}
          role="textbox"
          aria-label={`Add ${name === "dislikedIngredients" ? "disliked ingredients" : "preferred cuisines"}`}
        />

        {/* Tags display */}
        {value.length > 0 && (
          <div className="flex flex-wrap gap-2" role="list" aria-label="Selected items">
            {value.map((tag, index) => (
              <Badge key={`${tag}-${index}`} variant="secondary" className="gap-1 pl-2 pr-1" role="listitem">
                <span>{tag}</span>
                <button
                  type="button"
                  onClick={() => removeTag(index)}
                  className="ml-1 hover:bg-muted rounded-sm p-0.5"
                  aria-label={`Remove ${tag}`}
                >
                  <X className="h-3 w-3" aria-hidden="true" />
                </button>
              </Badge>
            ))}
          </div>
        )}

        {/* Helper text */}
        <p className="text-xs text-muted-foreground" aria-live="polite">
          Press Enter or comma to add. {value.length}/100 items.
        </p>
      </div>
    );
  }
);

TagsInput.displayName = "TagsInput";



================================================
FILE: src/components/theme/DarkModeToggle.tsx
================================================
import { Moon, Sun } from "lucide-react";
import { useTheme } from "./ThemeProvider";

/**
 * DarkModeToggle Component
 *
 * Minimalist toggle switch for light/dark theme.
 * Displays sliding animation when switching between modes.
 *
 * Features:
 * - Animated switch with sun/moon icons
 * - Smooth transitions
 * - Persists choice to localStorage
 * - Keyboard accessible
 *
 * @component
 */
export function DarkModeToggle() {
  const { resolvedTheme, setTheme } = useTheme();
  const isDark = resolvedTheme === "dark";

  const toggleTheme = () => {
    setTheme(isDark ? "light" : "dark");
  };

  return (
    <button
      onClick={toggleTheme}
      className="relative inline-flex h-8 w-14 items-center rounded-full transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 bg-muted hover:bg-muted/80"
      aria-label="Toggle theme"
      role="switch"
      aria-checked={isDark}
    >
      {/* Sliding circle */}
      <span
        className={`inline-flex h-6 w-6 transform items-center justify-center rounded-full bg-background shadow-sm transition-transform duration-200 ease-in-out ${
          isDark ? "translate-x-7" : "translate-x-1"
        }`}
      >
        {isDark ? (
          <Moon className="h-3.5 w-3.5 text-foreground" />
        ) : (
          <Sun className="h-3.5 w-3.5 text-foreground" />
        )}
      </span>
    </button>
  );
}



================================================
FILE: src/components/theme/ThemeProvider.tsx
================================================
import { createContext, useContext, useEffect, useState, type ReactNode } from "react";

type Theme = "light" | "dark" | "system";

interface ThemeContextType {
  theme: Theme;
  setTheme: (theme: Theme) => void;
  resolvedTheme: "light" | "dark";
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

interface ThemeProviderProps {
  children: ReactNode;
  defaultTheme?: Theme;
}

/**
 * ThemeProvider Component
 *
 * Manages dark mode theme state with localStorage persistence
 * and system preference detection.
 *
 * Features:
 * - Auto-detects system preference (prefers-color-scheme)
 * - Persists user choice to localStorage
 * - Provides theme context to all children
 * - Updates <html> class for Tailwind dark mode
 *
 * @component
 */
export function ThemeProvider({ children, defaultTheme = "system" }: ThemeProviderProps) {
  const [theme, setThemeState] = useState<Theme>(defaultTheme);
  const [resolvedTheme, setResolvedTheme] = useState<"light" | "dark">("light");

  useEffect(() => {
    // Load theme from localStorage on mount
    const stored = localStorage.getItem("theme") as Theme | null;
    if (stored) {
      setThemeState(stored);
    }
  }, []);

  useEffect(() => {
    const root = window.document.documentElement;

    // Remove previous theme classes
    root.classList.remove("light", "dark");

    let resolved: "light" | "dark";

    if (theme === "system") {
      // Use system preference
      const systemTheme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
      resolved = systemTheme;
    } else {
      resolved = theme;
    }

    // Add theme class to html element
    root.classList.add(resolved);
    setResolvedTheme(resolved);
  }, [theme]);

  // Listen for system theme changes
  useEffect(() => {
    if (theme !== "system") return;

    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    const handleChange = () => {
      const systemTheme = mediaQuery.matches ? "dark" : "light";
      const root = window.document.documentElement;
      root.classList.remove("light", "dark");
      root.classList.add(systemTheme);
      setResolvedTheme(systemTheme);
    };

    mediaQuery.addEventListener("change", handleChange);
    return () => mediaQuery.removeEventListener("change", handleChange);
  }, [theme]);

  const setTheme = (newTheme: Theme) => {
    setThemeState(newTheme);
    localStorage.setItem("theme", newTheme);
  };

  return <ThemeContext.Provider value={{ theme, setTheme, resolvedTheme }}>{children}</ThemeContext.Provider>;
}

/**
 * useTheme Hook
 *
 * Access theme context in any component.
 * Must be used within ThemeProvider.
 */
export function useTheme() {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error("useTheme must be used within a ThemeProvider");
  }
  return context;
}



================================================
FILE: src/components/ui/alert-dialog.tsx
================================================
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}



================================================
FILE: src/components/ui/alert.tsx
================================================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive:
          "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Alert({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) {
  return (
    <div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  )
}

function AlertTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-title"
      className={cn(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        className
      )}
      {...props}
    />
  )
}

function AlertDescription({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className
      )}
      {...props}
    />
  )
}

export { Alert, AlertTitle, AlertDescription }



================================================
FILE: src/components/ui/badge.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }



================================================
FILE: src/components/ui/button.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }



================================================
FILE: src/components/ui/card.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-2 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}



================================================
FILE: src/components/ui/dropdown-menu.tsx
================================================
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}



================================================
FILE: src/components/ui/input.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }



================================================
FILE: src/components/ui/label.tsx
================================================
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }



================================================
FILE: src/components/ui/select.tsx
================================================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  align = "center",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        align={align}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}



================================================
FILE: src/components/ui/skeleton.tsx
================================================
import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }



================================================
FILE: src/components/ui/sonner.tsx
================================================
import {
  CircleCheckIcon,
  InfoIcon,
  Loader2Icon,
  OctagonXIcon,
  TriangleAlertIcon,
} from "lucide-react"
import { Toaster as Sonner, type ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  return (
    <Sonner
      theme="light"
      className="toaster group"
      icons={{
        success: <CircleCheckIcon className="size-4" />,
        info: <InfoIcon className="size-4" />,
        warning: <TriangleAlertIcon className="size-4" />,
        error: <OctagonXIcon className="size-4" />,
        loading: <Loader2Icon className="size-4 animate-spin" />,
      }}
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
          "--border-radius": "var(--radius)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }



================================================
FILE: src/components/ui/tabs.tsx
================================================
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }



================================================
FILE: src/components/ui/textarea.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }



================================================
FILE: src/components/ui/tooltip.tsx
================================================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-foreground text-background animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-foreground fill-foreground z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }



================================================
FILE: src/db/database.types.ts
================================================
export type Json = string | number | boolean | null | { [key: string]: Json | undefined } | Json[];

export interface Database {
  graphql_public: {
    Tables: Record<never, never>;
    Views: Record<never, never>;
    Functions: {
      graphql: {
        Args: {
          extensions?: Json;
          operationName?: string;
          query?: string;
          variables?: Json;
        };
        Returns: Json;
      };
    };
    Enums: Record<never, never>;
    CompositeTypes: Record<never, never>;
  };
  public: {
    Tables: {
      events: {
        Row: {
          id: string;
          occurred_at: string;
          payload: Json | null;
          type: string;
          user_id: string;
        };
        Insert: {
          id?: string;
          occurred_at?: string;
          payload?: Json | null;
          type: string;
          user_id: string;
        };
        Update: {
          id?: string;
          occurred_at?: string;
          payload?: Json | null;
          type?: string;
          user_id?: string;
        };
        Relationships: [];
      };
      profiles: {
        Row: {
          created_at: string;
          diet_type: string | null;
          disliked_ingredients: string[] | null;
          preferred_cuisines: string[] | null;
          updated_at: string;
          user_id: string;
        };
        Insert: {
          created_at?: string;
          diet_type?: string | null;
          disliked_ingredients?: string[] | null;
          preferred_cuisines?: string[] | null;
          updated_at?: string;
          user_id: string;
        };
        Update: {
          created_at?: string;
          diet_type?: string | null;
          disliked_ingredients?: string[] | null;
          preferred_cuisines?: string[] | null;
          updated_at?: string;
          user_id?: string;
        };
        Relationships: [];
      };
      recipes: {
        Row: {
          created_at: string;
          id: string;
          ingredients_text: string[] | null;
          recipe: Json;
          search_tsv: unknown | null;
          summary: string | null;
          tags: string[] | null;
          title: string;
          updated_at: string;
          user_id: string;
        };
        Insert: {
          created_at?: string;
          id?: string;
          ingredients_text?: string[] | null;
          recipe: Json;
          search_tsv?: unknown | null;
          summary?: string | null;
          tags?: string[] | null;
          title: string;
          updated_at?: string;
          user_id: string;
        };
        Update: {
          created_at?: string;
          id?: string;
          ingredients_text?: string[] | null;
          recipe?: Json;
          search_tsv?: unknown | null;
          summary?: string | null;
          tags?: string[] | null;
          title?: string;
          updated_at?: string;
          user_id?: string;
        };
        Relationships: [];
      };
    };
    Views: Record<never, never>;
    Functions: {
      export_events_ndjson: {
        Args: { p_from_date?: string; p_to_date?: string };
        Returns: {
          event_json: Json;
        }[];
      };
      insert_recipe_safe: {
        Args: { p_recipe: Json; p_tags?: string[] };
        Returns: string;
      };
      normalize_text: {
        Args: { "": string };
        Returns: string;
      };
      unaccent: {
        Args: { "": string };
        Returns: string;
      };
      unaccent_init: {
        Args: { "": unknown };
        Returns: unknown;
      };
    };
    Enums: Record<never, never>;
    CompositeTypes: Record<never, never>;
  };
}

type DatabaseWithoutInternals = Omit<Database, "__InternalSupabase">;

type DefaultSchema = DatabaseWithoutInternals[Extract<keyof Database, "public">];

export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals;
  }
    ? keyof (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals;
}
  ? (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R;
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] & DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R;
      }
      ? R
      : never
    : never;

export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"] | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals;
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals;
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I;
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I;
      }
      ? I
      : never
    : never;

export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"] | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals;
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals;
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U;
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U;
      }
      ? U
      : never
    : never;

export type Enums<
  DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"] | { schema: keyof DatabaseWithoutInternals },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals;
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals;
}
  ? DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never;

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema["CompositeTypes"]
    | { schema: keyof DatabaseWithoutInternals },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals;
  }
    ? keyof DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals;
}
  ? DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
    ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never;

export const Constants = {
  graphql_public: {
    Enums: {},
  },
  public: {
    Enums: {},
  },
} as const;



================================================
FILE: src/db/supabase.client.ts
================================================
import type { AstroCookies } from "astro";
import { createClient } from "@supabase/supabase-js";
import { createServerClient, type CookieOptionsWithName } from "@supabase/ssr";

import type { Database } from "../db/database.types.ts";

// Use PUBLIC_ prefix for client-side access (browser)
// Fallback to non-PUBLIC for server-side compatibility
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL || import.meta.env.SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_KEY || import.meta.env.SUPABASE_KEY;

/**
 * Client-side Supabase client
 * Used for browser operations
 */
export const supabaseClient = createClient<Database>(supabaseUrl, supabaseAnonKey);

/**
 * Cookie options for SSR authentication
 */
export const cookieOptions: CookieOptionsWithName = {
  path: "/",
  secure: true,
  httpOnly: true,
  sameSite: "lax",
};

/**
 * Parse cookie header string into array of cookie objects
 */
function parseCookieHeader(cookieHeader: string): { name: string; value: string }[] {
  return cookieHeader.split(";").map((cookie) => {
    const [name, ...rest] = cookie.trim().split("=");
    return { name, value: rest.join("=") };
  });
}

/**
 * Create Supabase server instance for SSR
 * Handles cookie-based authentication with httpOnly cookies
 *
 * @param context - Astro request context with headers and cookies
 * @returns Configured Supabase server client
 */
export const createSupabaseServerInstance = (context: {
  headers: Headers;
  cookies: AstroCookies;
}) => {
  const supabase = createServerClient<Database>(
    supabaseUrl,
    supabaseAnonKey,
    {
      cookieOptions,
      cookies: {
        getAll() {
          return parseCookieHeader(context.headers.get("Cookie") ?? "");
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) =>
            context.cookies.set(name, value, options),
          );
        },
      },
    },
  );

  return supabase;
};



================================================
FILE: src/layouts/Layout.astro
================================================
---
import "../styles/global.css";
import { AppShell } from "../components/AppShell";

interface Props {
  title?: string;
  showHeader?: boolean;
}

const { title = "SavorAI", showHeader = true } = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/png" href="/favicon.png" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>
    <script is:inline>
      // Prevent FOUC (Flash of Unstyled Content) for dark mode
      // This runs before hydration to apply theme class immediately
      try {
        const theme = localStorage.getItem('theme') || 'system';
        const resolved = theme === 'system'
          ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light')
          : theme;
        document.documentElement.classList.add(resolved);
      } catch (e) {}
    </script>
  </head>
  <body>
    {showHeader && <AppShell client:only="react" />}
    <slot />
  </body>
</html>

<style>
  html,
  body {
    margin: 0;
    width: 100%;
    height: 100%;
  }
</style>



================================================
FILE: src/lib/utils.ts
================================================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}



================================================
FILE: src/lib/api/http.ts
================================================
import { supabaseClient } from "../../db/supabase.client";
import type { ApiError } from "../../types";

/**
 * Gets the current session access token
 * @returns Access token or null if not authenticated
 */
async function getAccessToken(): Promise<string | null> {
  const { data } = await supabaseClient.auth.getSession();
  const token = data.session?.access_token ?? null;
  console.log("[API] getAccessToken:", token ? `Token present (${token.substring(0, 20)}...)` : "No token");
  return token;
}

/**
 * Fetches from API with authorization header
 * Handles authentication, redirects on 401, and error parsing
 * @param url - API endpoint URL
 * @param options - Fetch options
 * @returns Response data
 * @throws ApiError on non-2xx responses
 */
export async function apiFetch<T>(url: string, options?: RequestInit): Promise<T> {
  const token = await getAccessToken();

  const headers: HeadersInit = {
    "Content-Type": "application/json",
    ...(options?.headers || {}),
  };

  if (token) {
    headers["Authorization"] = `Bearer ${token}`;
  }

  const response = await fetch(url, {
    ...options,
    headers,
  });

  console.log("[API] Response status:", response.status, "URL:", url);

  // Handle 401 Unauthorized - redirect to login
  if (response.status === 401) {
    console.log("[API] 401 Unauthorized - redirecting to /login");
    window.location.href = "/login";
    throw new Error("Unauthorized");
  }

  // Handle non-2xx responses
  if (!response.ok) {
    console.log("[API] Non-2xx response, trying to parse as JSON...");
    const contentType = response.headers.get("content-type");
    console.log("[API] Content-Type:", contentType);

    // Check if response is JSON
    if (contentType && contentType.includes("application/json")) {
      const error: ApiError = await response.json();
      console.log("[API] Error response:", error);
      throw error;
    } else {
      // Response is not JSON (might be HTML error page)
      const text = await response.text();
      console.log("[API] Non-JSON error response:", text.substring(0, 200));
      throw {
        error: "Server Error",
        message: `Server returned ${response.status}: ${response.statusText}`,
      } as ApiError;
    }
  }

  // Handle 204 No Content
  if (response.status === 204) {
    return {} as T;
  }

  console.log("[API] Parsing successful response as JSON...");
  const contentType = response.headers.get("content-type");
  console.log("[API] Success Content-Type:", contentType);

  if (!contentType || !contentType.includes("application/json")) {
    const text = await response.text();
    console.error("[API] Expected JSON but got:", text.substring(0, 200));
    throw {
      error: "Invalid Response",
      message: "Server did not return JSON",
    } as ApiError;
  }

  return response.json();
}



================================================
FILE: src/lib/api/profile.ts
================================================
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { apiFetch } from "./http";
import type {
  ProfileDTO,
  CreateProfileCommand,
  UpdateProfileCommand,
  ApiError,
} from "../../types";

// ============================================================================
// Profile API Functions
// ============================================================================

/**
 * Fetches user profile from GET /api/profile
 * @returns ProfileDTO or null if 404
 * @throws ApiError on other errors
 */
async function fetchProfile(): Promise<ProfileDTO | null> {
  try {
    return await apiFetch<ProfileDTO>("/api/profile");
  } catch (error) {
    // 404 means no profile exists - return null
    if ((error as ApiError).error === "Not Found") {
      return null;
    }
    throw error;
  }
}

/**
 * Creates a new profile via POST /api/profile
 * @param command - Create profile command
 * @returns Created profile DTO
 * @throws ApiError on validation or conflict errors
 */
async function createProfile(command: CreateProfileCommand): Promise<ProfileDTO> {
  return apiFetch<ProfileDTO>("/api/profile", {
    method: "POST",
    body: JSON.stringify(command),
  });
}

/**
 * Updates existing profile via PUT /api/profile
 * @param command - Update profile command
 * @returns Updated profile DTO
 * @throws ApiError on validation or not found errors
 */
async function updateProfile(command: UpdateProfileCommand): Promise<ProfileDTO> {
  console.log("[API] Updating profile with command:", command);
  return apiFetch<ProfileDTO>("/api/profile", {
    method: "PUT",
    body: JSON.stringify(command),
  });
}

// ============================================================================
// TanStack Query Hooks
// ============================================================================

/**
 * Query hook for fetching user profile
 * Returns null if profile doesn't exist (404)
 * Redirects to /login on 401
 */
export function useProfileQuery() {
  return useQuery({
    queryKey: ["profile"],
    queryFn: fetchProfile,
    retry: false, // Don't retry on 401 or 404
  });
}

/**
 * Mutation hook for creating a new profile
 * Invalidates profile cache on success
 */
export function useCreateProfileMutation() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: createProfile,
    onSuccess: () => {
      // Invalidate and refetch profile query
      queryClient.invalidateQueries({ queryKey: ["profile"] });
    },
  });
}

/**
 * Mutation hook for updating existing profile
 * Invalidates profile cache on success
 */
export function useUpdateProfileMutation() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: updateProfile,
    onSuccess: () => {
      // Invalidate and refetch profile query
      queryClient.invalidateQueries({ queryKey: ["profile"] });
    },
  });
}



================================================
FILE: src/lib/api/recipes.ts
================================================
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useQueryClient,
} from "@tanstack/react-query";
import { apiFetch } from "./http";
import type {
  RecipeListResponse,
  RecipeDetailsDTO,
  GenerateRecipeCommand,
  GenerateRecipeResponse,
  SaveRecipeCommand,
  RecipeSummaryDTO,
  ApiError,
  RecipeQueryParams,
} from "../../types";

// ============================================================================
// Recipe API Functions
// ============================================================================

/**
 * Fetches recipe list from GET /api/recipes
 * Supports search, filtering, sorting, and pagination
 * @param params - Query parameters
 * @returns Recipe list response with pagination metadata
 * @throws ApiError on validation or server errors
 */
async function fetchRecipeList(params: RecipeQueryParams): Promise<RecipeListResponse> {
  const searchParams = new URLSearchParams();

  if (params.search) searchParams.set("search", params.search);
  if (params.tags) searchParams.set("tags", params.tags);
  if (params.sort) searchParams.set("sort", params.sort);
  if (params.limit) searchParams.set("limit", params.limit.toString());
  if (params.cursor) searchParams.set("cursor", params.cursor);
  if (params.offset !== undefined) searchParams.set("offset", params.offset.toString());

  const url = `/api/recipes${searchParams.toString() ? `?${searchParams.toString()}` : ""}`;
  return apiFetch<RecipeListResponse>(url);
}

/**
 * Fetches recipe details from GET /api/recipes/:id
 * @param id - Recipe ID
 * @returns Recipe details DTO
 * @throws ApiError on 404 or other errors
 */
async function fetchRecipeDetails(id: string): Promise<RecipeDetailsDTO> {
  return apiFetch<RecipeDetailsDTO>(`/api/recipes/${id}`);
}

/**
 * Generates a new recipe via POST /api/recipes/generate
 * @param command - Generate recipe command with prompt
 * @returns Generated recipe response
 * @throws ApiError on validation, 413, 429, or server errors
 */
async function generateRecipe(command: GenerateRecipeCommand): Promise<GenerateRecipeResponse> {
  return apiFetch<GenerateRecipeResponse>("/api/recipes/generate", {
    method: "POST",
    body: JSON.stringify(command),
  });
}

/**
 * Saves a recipe via POST /api/recipes
 * @param command - Save recipe command with recipe and optional tags
 * @returns Recipe summary DTO
 * @throws ApiError on validation, disliked ingredients, 413, or server errors
 */
async function saveRecipe(command: SaveRecipeCommand): Promise<RecipeSummaryDTO> {
  return apiFetch<RecipeSummaryDTO>("/api/recipes", {
    method: "POST",
    body: JSON.stringify(command),
  });
}

/**
 * Deletes a recipe via DELETE /api/recipes/:id
 * @param id - Recipe ID
 * @throws ApiError on 404 or server errors
 */
async function deleteRecipe(id: string): Promise<void> {
  return apiFetch<void>(`/api/recipes/${id}`, {
    method: "DELETE",
  });
}

// ============================================================================
// TanStack Query Hooks
// ============================================================================

/**
 * Infinite query hook for fetching paginated recipe list
 * Uses offset-based pagination (MVP) with support for cursor-based in the future
 * Automatically handles "Load More" functionality
 *
 * @param params - Base query parameters (search, tags, sort, limit)
 * @returns Infinite query result with pages array and fetchNextPage function
 */
export function useRecipesList(params: Omit<RecipeQueryParams, "offset" | "cursor">) {
  return useInfiniteQuery({
    queryKey: ["recipes", params],
    queryFn: ({ pageParam = 0 }) =>
      fetchRecipeList({
        ...params,
        offset: pageParam,
      }),
    getNextPageParam: (lastPage, allPages) => {
      if (!lastPage.pagination.has_more) {
        return undefined;
      }
      // Calculate next offset based on accumulated data
      const currentOffset = allPages.reduce((acc, page) => acc + page.data.length, 0);
      return currentOffset;
    },
    initialPageParam: 0,
    retry: false,
  });
}

/**
 * Query hook for fetching single recipe details
 * Returns full recipe data including JSONB
 *
 * @param id - Recipe ID
 * @returns Query result with recipe details
 */
export function useRecipeDetails(id: string) {
  return useQuery({
    queryKey: ["recipe", id],
    queryFn: () => fetchRecipeDetails(id),
    retry: false,
    enabled: !!id, // Only run query if id is provided
  });
}

/**
 * Mutation hook for generating a recipe via AI
 * Does not invalidate any cache as generation doesn't affect saved recipes
 *
 * @returns Mutation result for recipe generation
 */
export function useGenerateRecipeMutation() {
  return useMutation({
    mutationFn: generateRecipe,
  });
}

/**
 * Mutation hook for saving a recipe
 * Invalidates recipe list cache on success to show the new recipe
 *
 * @returns Mutation result for saving recipe
 */
export function useSaveRecipeMutation() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: saveRecipe,
    onSuccess: () => {
      // Invalidate recipe list to refresh with new recipe
      queryClient.invalidateQueries({ queryKey: ["recipes"] });
    },
  });
}

/**
 * Mutation hook for deleting a recipe
 * Invalidates both recipe list and the specific recipe cache on success
 *
 * @returns Mutation result for deleting recipe
 */
export function useDeleteRecipeMutation() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: deleteRecipe,
    onSuccess: (_, deletedId) => {
      // Invalidate recipe list to remove deleted recipe
      queryClient.invalidateQueries({ queryKey: ["recipes"] });
      // Invalidate the specific recipe cache
      queryClient.invalidateQueries({ queryKey: ["recipe", deletedId] });
    },
  });
}



================================================
FILE: src/lib/auth/api.ts
================================================
/**
 * Auth API Types and Client Functions
 *
 * TypeScript types and client functions for authentication API endpoints.
 */

/**
 * User object returned from auth endpoints
 */
export interface AuthUser {
  id: string;
  email?: string;
}

/**
 * Success response from login/register endpoints
 */
export interface AuthSuccessResponse {
  user: AuthUser;
}

/**
 * Error response from auth endpoints
 */
export interface AuthErrorResponse {
  error: string;
}

/**
 * Login credentials
 */
export interface LoginCredentials {
  email: string;
  password: string;
}

/**
 * Register credentials
 */
export interface RegisterCredentials {
  email: string;
  password: string;
}

/**
 * Call login endpoint
 *
 * @param credentials - Email and password
 * @returns User data or throws error
 */
export async function login(credentials: LoginCredentials): Promise<AuthUser> {
  const response = await fetch("/api/auth/login", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(credentials),
  });

  const data = await response.json();

  if (!response.ok) {
    throw new Error((data as AuthErrorResponse).error || "Login failed");
  }

  return (data as AuthSuccessResponse).user;
}

/**
 * Call register endpoint
 *
 * @param credentials - Email and password
 * @returns User data or throws error
 */
export async function register(credentials: RegisterCredentials): Promise<AuthUser> {
  const response = await fetch("/api/auth/register", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(credentials),
  });

  const data = await response.json();

  if (!response.ok) {
    throw new Error((data as AuthErrorResponse).error || "Registration failed");
  }

  return (data as AuthSuccessResponse).user;
}

/**
 * Call logout endpoint
 *
 * @throws Error if logout fails
 */
export async function logout(): Promise<void> {
  const response = await fetch("/api/auth/logout", {
    method: "POST",
  });

  if (!response.ok) {
    const data = await response.json();
    throw new Error((data as AuthErrorResponse).error || "Logout failed");
  }
}



================================================
FILE: src/lib/auth/telemetry.ts
================================================
import { supabaseClient } from "../../db/supabase.client";

/**
 * SessionStorage key for tracking if session_start event was sent
 */
const SESSION_START_KEY = "session_start_logged";

/**
 * Send session_start event to analytics
 *
 * Best-effort: Does not throw errors, logs failures to console.
 * Requires authenticated user session.
 *
 * @returns Promise that resolves when event is sent (or fails silently)
 */
export async function sendSessionStartEvent(): Promise<void> {
  try {
    // Get current session and access token
    const {
      data: { session },
      error: sessionError,
    } = await supabaseClient.auth.getSession();

    if (sessionError || !session?.access_token) {
      console.debug("Cannot send session_start event: No valid session");
      return;
    }

    // Send event to /api/events
    const response = await fetch("/api/events", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${session.access_token}`,
      },
      body: JSON.stringify({
        type: "session_start",
      }),
    });

    if (!response.ok) {
      console.debug(
        `session_start event failed: ${response.status} ${response.statusText}`
      );
    } else {
      console.debug("session_start event sent successfully");
    }
  } catch (error) {
    // Best-effort: Log and ignore errors
    console.debug("Failed to send session_start event:", error);
  }
}

/**
 * Send session_start event on cold start (if not already sent in this browser session)
 *
 * Uses sessionStorage to track if event was already sent.
 * Best-effort: Does not throw errors.
 *
 * @returns Promise that resolves when event is sent or skipped
 */
export async function sendSessionStartOnColdStart(): Promise<void> {
  try {
    // Check if already sent in this browser session
    if (sessionStorage.getItem(SESSION_START_KEY) === "1") {
      console.debug("session_start event already sent in this session");
      return;
    }

    // Send event
    await sendSessionStartEvent();

    // Mark as sent
    sessionStorage.setItem(SESSION_START_KEY, "1");
  } catch (error) {
    // Best-effort: Ignore sessionStorage errors
    console.debug("Failed to track session_start in sessionStorage:", error);
  }
}

/**
 * Clear session_start tracking flag
 * Call this on logout to allow fresh tracking on next login
 */
export function clearSessionStartTracking(): void {
  try {
    sessionStorage.removeItem(SESSION_START_KEY);
  } catch (error) {
    console.debug("Failed to clear session_start tracking:", error);
  }
}



================================================
FILE: src/lib/auth/types.ts
================================================
/**
 * Auth ViewModel Types
 * Used for login/register UI components
 */

/**
 * Auth form mode - login or register
 */
export type AuthFormMode = "login" | "register";

/**
 * Auth form values (ViewModel)
 */
export interface AuthFormValues {
  email: string;
  password: string;
}

/**
 * Auth form field errors
 */
export interface AuthFormErrors {
  email?: string;
  password?: string;
  form?: string; // Global form error
}

/**
 * Auth result (placeholder for future backend integration)
 */
export interface AuthResult {
  ok: boolean;
  error?: string;
}

/**
 * Auth view model - complete form state
 */
export interface AuthViewModel {
  mode: AuthFormMode;
  values: AuthFormValues;
  errors: AuthFormErrors;
  loading: boolean;
}



================================================
FILE: src/lib/auth/useAuth.ts
================================================
import { useState, useEffect } from "react";
import type { User } from "@supabase/supabase-js";
import { supabaseClient } from "../../db/supabase.client";
import { sendSessionStartOnColdStart } from "./telemetry";

/**
 * Authentication state
 */
export interface AuthState {
  user: User | null;
  loading: boolean;
}

/**
 * useAuth Hook
 *
 * Client-side hook for accessing current user session.
 * Automatically subscribes to auth state changes.
 *
 * @returns Current user and loading state
 *
 * @example
 * const { user, loading } = useAuth();
 * if (loading) return <Spinner />;
 * if (user) return <div>Welcome {user.email}</div>;
 */
export function useAuth(): AuthState {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Get initial session
    supabaseClient.auth.getSession().then(({ data: { session } }) => {
      setUser(session?.user ?? null);
      setLoading(false);

      // Send session_start event on cold start (if session exists and not already sent)
      if (session?.user) {
        sendSessionStartOnColdStart().catch(() => {
          // Ignore telemetry errors - don't block UX
        });
      }
    });

    // Subscribe to auth state changes
    const {
      data: { subscription },
    } = supabaseClient.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null);
      setLoading(false);
    });

    // Cleanup subscription
    return () => subscription.unsubscribe();
  }, []);

  return { user, loading };
}



================================================
FILE: src/lib/auth/validation.ts
================================================
import type { AuthFormValues, AuthFormErrors } from "./types";

/**
 * Email validation - RFC 5322 lite (moderate regex)
 * Max 254 characters
 */
export function validateEmail(email: string): string | undefined {
  const trimmed = email.trim();

  if (!trimmed) {
    return "Email is required";
  }

  if (trimmed.length > 254) {
    return "Email must be 254 characters or less";
  }

  // RFC 5322 lite pattern
  const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailPattern.test(trimmed)) {
    return "Please enter a valid email address";
  }

  return undefined;
}

/**
 * Password validation
 * Min 8 characters, max 128 characters
 * No whitespace-only passwords
 */
export function validatePassword(password: string): string | undefined {
  if (!password) {
    return "Password is required";
  }

  if (password.trim().length === 0) {
    return "Password cannot be only whitespace";
  }

  if (password.length < 8) {
    return "Password must be at least 8 characters";
  }

  if (password.length > 128) {
    return "Password must be 128 characters or less";
  }

  return undefined;
}

/**
 * Validates entire auth form
 * Returns errors object (empty if valid)
 */
export function validateAuthForm(values: AuthFormValues): AuthFormErrors {
  const errors: AuthFormErrors = {};

  const emailError = validateEmail(values.email);
  if (emailError) {
    errors.email = emailError;
  }

  const passwordError = validatePassword(values.password);
  if (passwordError) {
    errors.password = passwordError;
  }

  return errors;
}

/**
 * Checks if form has any errors
 */
export function hasErrors(errors: AuthFormErrors): boolean {
  return !!(errors.email || errors.password || errors.form);
}

/**
 * Normalizes email (trim + lowercase)
 */
export function normalizeEmail(email: string): string {
  return email.trim().toLowerCase();
}



================================================
FILE: src/lib/hooks/useScrollRestoration.ts
================================================
import { useEffect, useRef } from "react";

/**
 * Custom hook for saving and restoring scroll position
 * Uses sessionStorage to persist scroll position across navigation
 *
 * @param key - Unique key for this scroll position (e.g., URL search params)
 * @returns Ref to attach to scrollable element
 */
export function useScrollRestoration<T extends HTMLElement = HTMLDivElement>(key: string) {
  const elementRef = useRef<T>(null);
  const storageKey = `scroll-${key}`;

  // Restore scroll position on mount
  useEffect(() => {
    const element = elementRef.current;
    if (!element) return;

    // Restore saved position
    const savedPosition = sessionStorage.getItem(storageKey);
    if (savedPosition) {
      const position = parseInt(savedPosition, 10);
      if (!isNaN(position)) {
        // Use setTimeout to ensure DOM is ready
        setTimeout(() => {
          element.scrollTop = position;
        }, 0);
      }
    }
  }, [storageKey]);

  // Save scroll position when scrolling
  useEffect(() => {
    const element = elementRef.current;
    if (!element) return;

    let timeoutId: NodeJS.Timeout;

    const handleScroll = () => {
      // Debounce to avoid too many writes
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => {
        sessionStorage.setItem(storageKey, element.scrollTop.toString());
      }, 100);
    };

    element.addEventListener("scroll", handleScroll, { passive: true });

    return () => {
      clearTimeout(timeoutId);
      element.removeEventListener("scroll", handleScroll);
    };
  }, [storageKey]);

  return elementRef;
}



================================================
FILE: src/lib/hooks/useUrlFilters.ts
================================================
import { useState, useEffect, useCallback } from "react";
import type { ListFiltersVM, RecipeSortOrder } from "@/types";

/**
 * Default filter values
 */
const DEFAULT_FILTERS: ListFiltersVM = {
  search: "",
  tags: [],
  sort: "recent",
  limit: 20,
  offset: 0,
};

/**
 * Parse URL search params into ListFiltersVM
 */
function parseFiltersFromUrl(searchParams: URLSearchParams): ListFiltersVM {
  const filters: ListFiltersVM = { ...DEFAULT_FILTERS };

  // Parse search
  const search = searchParams.get("search");
  if (search) {
    filters.search = search;
  }

  // Parse tags (comma-separated)
  const tags = searchParams.get("tags");
  if (tags) {
    filters.tags = tags.split(",").filter((t) => t.trim().length > 0);
  }

  // Parse sort
  const sort = searchParams.get("sort") as RecipeSortOrder | null;
  if (sort === "recent" || sort === "oldest") {
    filters.sort = sort;
  }

  // Parse limit
  const limit = searchParams.get("limit");
  if (limit) {
    const parsed = parseInt(limit, 10);
    if (!isNaN(parsed) && parsed >= 1 && parsed <= 100) {
      filters.limit = parsed;
    }
  }

  // Parse offset
  const offset = searchParams.get("offset");
  if (offset) {
    const parsed = parseInt(offset, 10);
    if (!isNaN(parsed) && parsed >= 0) {
      filters.offset = parsed;
    }
  }

  return filters;
}

/**
 * Convert ListFiltersVM to URLSearchParams
 */
function filtersToSearchParams(filters: ListFiltersVM): URLSearchParams {
  const params = new URLSearchParams();

  if (filters.search && filters.search.trim()) {
    params.set("search", filters.search.trim());
  }

  if (filters.tags.length > 0) {
    params.set("tags", filters.tags.join(","));
  }

  if (filters.sort && filters.sort !== "recent") {
    params.set("sort", filters.sort);
  }

  if (filters.limit && filters.limit !== 20) {
    params.set("limit", filters.limit.toString());
  }

  if (filters.offset && filters.offset > 0) {
    params.set("offset", filters.offset.toString());
  }

  return params;
}

/**
 * Custom hook for managing recipe list filters in URL
 * Synchronizes filter state with URL search params
 * Supports browser back/forward navigation
 */
export function useUrlFilters() {
  // Initialize from URL
  const [filters, setFiltersState] = useState<ListFiltersVM>(() => {
    if (typeof window === "undefined") return DEFAULT_FILTERS;
    const params = new URLSearchParams(window.location.search);
    return parseFiltersFromUrl(params);
  });

  // Update URL when filters change
  const updateUrl = useCallback((newFilters: ListFiltersVM) => {
    const params = filtersToSearchParams(newFilters);
    const newUrl = `${window.location.pathname}${params.toString() ? `?${params.toString()}` : ""}`;
    window.history.pushState({}, "", newUrl);
  }, []);

  // Set filters and update URL
  const setFilters = useCallback(
    (updater: ListFiltersVM | ((prev: ListFiltersVM) => ListFiltersVM)) => {
      setFiltersState((prev) => {
        const newFilters = typeof updater === "function" ? updater(prev) : updater;
        updateUrl(newFilters);
        return newFilters;
      });
    },
    [updateUrl]
  );

  // Handle browser back/forward
  useEffect(() => {
    const handlePopState = () => {
      const params = new URLSearchParams(window.location.search);
      const newFilters = parseFiltersFromUrl(params);
      setFiltersState(newFilters);
    };

    window.addEventListener("popstate", handlePopState);
    return () => window.removeEventListener("popstate", handlePopState);
  }, []);

  return { filters, setFilters };
}



================================================
FILE: src/lib/mappers/profile.ts
================================================
import type { ProfileDTO, CreateProfileCommand, UpdateProfileCommand, DietType } from "../../types";

// ============================================================================
// ViewModel Types
// ============================================================================

/**
 * Profile operation mode
 */
export type ProfileOperation = "create" | "update";

/**
 * Profile Form Values (ViewModel)
 * Used in the profile form - client-side representation
 */
export interface ProfileFormValues {
  dietType: DietType | null;
  dislikedIngredients: string[];
  preferredCuisines: string[];
}

// ============================================================================
// Mapping Functions
// ============================================================================

/**
 * Maps ProfileDTO from API to ProfileFormValues for form initialization
 * @param dto - Profile DTO from GET /api/profile
 * @returns ProfileFormValues for form
 */
export function profileDtoToFormValues(dto: ProfileDTO): ProfileFormValues {
  return {
    dietType: dto.diet_type ?? null,
    dislikedIngredients: dto.disliked_ingredients ?? [],
    preferredCuisines: dto.preferred_cuisines ?? [],
  };
}

/**
 * Creates empty ProfileFormValues
 * @returns Empty form values for create mode
 */
export function emptyProfileFormValues(): ProfileFormValues {
  return {
    dietType: null,
    dislikedIngredients: [],
    preferredCuisines: [],
  };
}

/**
 * Maps ProfileFormValues to CreateProfileCommand for POST /api/profile
 * Only includes non-empty fields (at least one field must be present per PRD)
 * @param values - Form values
 * @returns CreateProfileCommand for API
 */
export function formValuesToCreateCommand(values: ProfileFormValues): CreateProfileCommand {
  const command: CreateProfileCommand = {};

  if (values.dietType) {
    command.diet_type = values.dietType;
  }

  if (values.dislikedIngredients.length > 0) {
    command.disliked_ingredients = values.dislikedIngredients;
  }

  if (values.preferredCuisines.length > 0) {
    command.preferred_cuisines = values.preferredCuisines;
  }

  return command;
}

/**
 * Maps ProfileFormValues to UpdateProfileCommand for PUT /api/profile
 * Includes only changed fields compared to initial values
 * Uses null to clear diet_type field
 * @param values - Current form values
 * @param initialValues - Initial form values (from server)
 * @returns UpdateProfileCommand for API
 */
export function formValuesToUpdateCommand(
  values: ProfileFormValues,
  initialValues: ProfileFormValues
): UpdateProfileCommand {
  const command: UpdateProfileCommand = {};

  // Check if dietType changed
  if (values.dietType !== initialValues.dietType) {
    command.diet_type = values.dietType;
  }

  // Check if dislikedIngredients changed
  if (!arraysEqual(values.dislikedIngredients, initialValues.dislikedIngredients)) {
    command.disliked_ingredients = values.dislikedIngredients;
  }

  // Check if preferredCuisines changed
  if (!arraysEqual(values.preferredCuisines, initialValues.preferredCuisines)) {
    command.preferred_cuisines = values.preferredCuisines;
  }

  return command;
}

// ============================================================================
// Normalization and Validation Helpers
// ============================================================================

/**
 * Normalizes a tag/ingredient string array
 * - Trims whitespace
 * - Converts to lowercase
 * - Removes duplicates
 * - Filters out empty strings
 * @param items - Array of strings
 * @returns Normalized array
 */
export function normalizeStringArray(items: string[]): string[] {
  const normalized = items.map((item) => item.trim().toLowerCase()).filter((item) => item.length > 0);

  // Remove duplicates
  return Array.from(new Set(normalized));
}

/**
 * Validates that at least one field is filled (PRD requirement)
 * @param values - Form values
 * @returns true if at least one field has value
 */
export function hasAtLeastOneField(values: ProfileFormValues): boolean {
  return (
    values.dietType !== null || values.dislikedIngredients.length > 0 || values.preferredCuisines.length > 0
  );
}

/**
 * Checks if form has changes compared to initial values
 * @param values - Current form values
 * @param initialValues - Initial form values
 * @returns true if form is dirty (has changes)
 */
export function isFormDirty(values: ProfileFormValues, initialValues: ProfileFormValues): boolean {
  return (
    values.dietType !== initialValues.dietType ||
    !arraysEqual(values.dislikedIngredients, initialValues.dislikedIngredients) ||
    !arraysEqual(values.preferredCuisines, initialValues.preferredCuisines)
  );
}

/**
 * Compares two string arrays for equality
 * @param a - First array
 * @param b - Second array
 * @returns true if arrays are equal
 */
function arraysEqual(a: string[], b: string[]): boolean {
  if (a.length !== b.length) return false;
  const sortedA = [...a].sort();
  const sortedB = [...b].sort();
  return sortedA.every((val, index) => val === sortedB[index]);
}



================================================
FILE: src/lib/schemas/common.schema.ts
================================================
import { z } from "zod";

/**
 * Common validation schemas
 * Shared across multiple endpoints
 */

/**
 * UUID validation schema
 * Validates that a string is a valid UUID v4
 */
export const UuidSchema = z.string().uuid({
  message: "Invalid UUID format",
});

/**
 * Validate UUID parameter
 * Returns validated UUID or throws ZodError
 */
export function validateUuid(value: unknown): string {
  return UuidSchema.parse(value);
}



================================================
FILE: src/lib/schemas/events.schema.ts
================================================
import { z } from "zod";

/**
 * Event Type Schema
 * Must match EventType in src/types.ts and CHECK constraint in database
 */
const EventTypeSchema = z.enum([
  "session_start",
  "profile_edited",
  "ai_prompt_sent",
  "ai_recipe_generated",
  "recipe_saved",
]);

/**
 * Payload size limit in bytes (8 KB)
 * Prevents excessive payload sizes that could impact database performance
 */
const MAX_PAYLOAD_SIZE = 8192;

/**
 * Create Event Command Schema
 * Validates the body of POST /api/events
 *
 * Rules:
 * - type: Must be one of the allowed EventType values
 * - payload: Optional JSON data, limited to 8 KB when serialized
 */
export const CreateEventCommandSchema = z
  .object({
    type: EventTypeSchema,
    payload: z.any().optional(),
  })
  .strict()
  .refine(
    (data) => {
      // If no payload, always valid
      if (!data.payload) return true;

      // Check serialized size
      try {
        const serialized = JSON.stringify(data.payload);
        return serialized.length <= MAX_PAYLOAD_SIZE;
      } catch {
        // If JSON.stringify fails, it's invalid JSON
        return false;
      }
    },
    {
      message: `Payload size must not exceed ${MAX_PAYLOAD_SIZE} bytes when serialized`,
      path: ["payload"],
    }
  );

/**
 * Type inference for CreateEventCommand after Zod validation
 */
export type CreateEventCommandInput = z.infer<typeof CreateEventCommandSchema>;



================================================
FILE: src/lib/schemas/profile.schema.ts
================================================
import { z } from "zod";

/**
 * Diet Type Schema
 * Must match DietType in src/types.ts and CHECK constraint in database
 */
const DietTypeSchema = z.enum([
  "vegan",
  "vegetarian",
  "pescatarian",
  "keto",
  "paleo",
  "gluten_free",
  "dairy_free",
  "low_carb",
  "mediterranean",
  "omnivore",
]);

/**
 * String Array Normalizer
 * Transforms array of strings by:
 * - Converting to lowercase
 * - Trimming whitespace
 * - Filtering out empty strings
 * - Removing duplicates
 */
const normalizeStringArray = (arr: string[]): string[] => {
  const normalized = arr
    .map((item) => item.trim().toLowerCase())
    .filter((item) => item.length > 0);

  // Remove duplicates
  return [...new Set(normalized)];
};

/**
 * String Array Schema
 * Validates and normalizes string arrays for ingredients and cuisines
 * - Each string: 1-50 characters after trim
 * - Max 100 items in array
 * - Automatically normalizes to lowercase, trims, deduplicates
 */
const StringArraySchema = z
  .array(
    z
      .string()
      .min(1, "Item cannot be empty")
      .max(50, "Item cannot exceed 50 characters")
  )
  .max(100, "Array cannot exceed 100 items")
  .transform(normalizeStringArray);

/**
 * Create Profile Command Schema
 * Validates the body of POST /api/profile
 *
 * Rules:
 * - diet_type: Optional, must be one of the allowed DietType values
 * - disliked_ingredients: Optional array of strings (1-50 chars each, max 100 items)
 *   Automatically normalized: lowercase, trimmed, deduplicated, empty filtered
 * - preferred_cuisines: Optional array of strings (same rules as disliked_ingredients)
 * - All fields are optional as user can create empty profile
 */
export const CreateProfileCommandSchema = z
  .object({
    diet_type: DietTypeSchema.optional(),
    disliked_ingredients: StringArraySchema.optional(),
    preferred_cuisines: StringArraySchema.optional(),
  })
  .strict();

/**
 * Update Profile Command Schema
 * Validates the body of PUT /api/profile
 *
 * Rules:
 * - All fields optional for partial updates
 * - At least one field must be provided
 * - diet_type can be explicitly set to null to clear the value
 */
export const UpdateProfileCommandSchema = z
  .object({
    diet_type: DietTypeSchema.nullish(),
    disliked_ingredients: StringArraySchema.optional(),
    preferred_cuisines: StringArraySchema.optional(),
  })
  .strict()
  .refine(
    (data) =>
      data.diet_type !== undefined ||
      data.disliked_ingredients !== undefined ||
      data.preferred_cuisines !== undefined,
    {
      message: "At least one field must be provided for update",
      path: ["_root"],
    }
  );

/**
 * Type inference for CreateProfileCommand after Zod validation
 */
export type CreateProfileCommandInput = z.infer<typeof CreateProfileCommandSchema>;

/**
 * Type inference for UpdateProfileCommand after Zod validation
 */
export type UpdateProfileCommandInput = z.infer<typeof UpdateProfileCommandSchema>;



================================================
FILE: src/lib/schemas/recipe.schema.ts
================================================
import { z } from "zod";
import type { RecipeSchema } from "../../types";

/**
 * Zod schema for dietary information
 */
const DietaryInfoSchema = z
  .object({
    vegetarian: z.boolean().optional(),
    vegan: z.boolean().optional(),
    gluten_free: z.boolean().optional(),
    dairy_free: z.boolean().optional(),
    nut_free: z.boolean().optional(),
  })
  .catchall(z.boolean())
  .optional();

/**
 * Zod schema for nutrition information
 */
const NutritionSchema = z
  .object({
    calories: z.number().int().nonnegative().optional(),
    protein_g: z.number().nonnegative().optional(),
    carbs_g: z.number().nonnegative().optional(),
    fat_g: z.number().nonnegative().optional(),
  })
  .catchall(z.number())
  .optional();

/**
 * Zod schema for RecipeSchema
 * Validates the complete recipe structure from AI generation
 */
export const RecipeSchemaZ = z.object({
  title: z.string().min(1).max(200),
  summary: z.string().max(500).optional(),
  description: z.string().max(2000).optional(),
  prep_time_minutes: z.number().int().nonnegative().max(1440), // Max 24 hours
  cook_time_minutes: z.number().int().nonnegative().max(1440), // Max 24 hours
  servings: z.number().int().positive().max(100),
  difficulty: z.enum(["easy", "medium", "hard"]),
  cuisine: z.string().max(50).optional(),
  ingredients: z.array(z.string().min(1).max(500)).min(1).max(100),
  instructions: z.array(z.string().min(1).max(2000)).min(1).max(50),
  tags: z.array(z.string().min(1).max(50)).max(20).optional(),
  dietary_info: DietaryInfoSchema,
  nutrition: NutritionSchema,
}) satisfies z.ZodType<RecipeSchema>;

/**
 * Zod schema for GenerateRecipeCommand
 * Validates the prompt input with sanity checks
 */
export const GenerateRecipeCommandSchema = z.object({
  prompt: z
    .string()
    .trim()
    .min(1, "Prompt cannot be empty")
    .max(2000, "Prompt too long (max 2000 characters)")
    .refine(
      (val) => {
        // Basic sanity check: no control characters except newlines and tabs
        const hasInvalidChars = /[\x00-\x08\x0B-\x0C\x0E-\x1F\x7F]/.test(val);
        return !hasInvalidChars;
      },
      { message: "Prompt contains invalid control characters" }
    )
    .refine(
      (val) => {
        // Soft check for potential prompt injection patterns
        const suspiciousPatterns = [
          /ignore\s+(previous|all)\s+(instructions|prompts)/i,
          /system\s*:\s*/i,
          /assistant\s*:\s*/i,
        ];
        return !suspiciousPatterns.some((pattern) => pattern.test(val));
      },
      { message: "Prompt contains suspicious patterns" }
    ),
});

/**
 * Zod schema for GenerateRecipeResponse
 */
export const GenerateRecipeResponseSchema = z.object({
  recipe: RecipeSchemaZ,
  generation_id: z.string().uuid(),
  generated_at: z.string().datetime(),
});

/**
 * Zod schema for SaveRecipeCommand
 * Validates recipe save request with optional tags
 */
export const SaveRecipeCommandSchema = z.object({
  recipe: RecipeSchemaZ,
  tags: z
    .array(z.string().trim().min(1, "Tag cannot be empty").max(50, "Tag too long (max 50 characters)"))
    .max(20, "Too many tags (max 20)")
    .optional(),
});

/**
 * Helper function to normalize tags
 * Converts to lowercase, trims whitespace, removes duplicates and empty strings
 * @param tags - Array of tag strings to normalize
 * @returns Normalized array of unique lowercase tags
 */
export function normalizeTags(tags: string[] | undefined): string[] {
  if (!tags || tags.length === 0) {
    return [];
  }

  const normalized = tags
    .map((tag) => tag.trim().toLowerCase())
    .filter((tag) => tag.length > 0);

  // Remove duplicates while preserving order
  return Array.from(new Set(normalized));
}

/**
 * Type inference helpers
 */
export type RecipeSchemaInput = z.input<typeof RecipeSchemaZ>;
export type RecipeSchemaOutput = z.output<typeof RecipeSchemaZ>;
export type GenerateRecipeCommandInput = z.input<typeof GenerateRecipeCommandSchema>;
export type SaveRecipeCommandInput = z.input<typeof SaveRecipeCommandSchema>;



================================================
FILE: src/lib/schemas/recipes.schema.ts
================================================
import { z } from "zod";

/**
 * Recipe sort order validation
 */
const RecipeSortOrderSchema = z.enum(["recent", "oldest"], {
  errorMap: () => ({ message: "Sort must be 'recent' or 'oldest'" }),
});

/**
 * Recipe query parameters validation schema
 * For GET /api/recipes endpoint
 */
export const RecipeListQuerySchema = z
  .object({
    // Full-text search across title, summary, ingredients
    search: z
      .string()
      .trim()
      .max(200, "Search query too long (max 200 characters)")
      .optional()
      .transform((val) => (val && val.length > 0 ? val : undefined)),

    // Comma-separated tags for OR filtering
    tags: z
      .string()
      .trim()
      .max(200, "Tags parameter too long (max 200 characters)")
      .optional()
      .transform((val) => {
        if (!val || val.length === 0) return undefined;
        // Normalize to lowercase and split
        return val
          .toLowerCase()
          .split(",")
          .map((t) => t.trim())
          .filter((t) => t.length > 0);
      }),

    // Sort order (default: recent)
    sort: RecipeSortOrderSchema.default("recent"),

    // Pagination limit (default: 20, range: 1-100)
    limit: z
      .string()
      .optional()
      .default("20")
      .transform((val) => parseInt(val, 10))
      .pipe(z.number().int().min(1, "Limit must be at least 1").max(100, "Limit cannot exceed 100")),

    // Cursor-based pagination (Base64 encoded "created_at:id")
    cursor: z
      .string()
      .trim()
      .optional()
      .transform((val) => (val && val.length > 0 ? val : undefined)),

    // Offset-based pagination (alternative to cursor)
    offset: z
      .string()
      .optional()
      .transform((val) => (val && val.length > 0 ? parseInt(val, 10) : undefined))
      .pipe(z.number().int().nonnegative("Offset must be non-negative").optional()),
  })
  .strict()
  .refine(
    (data) => {
      // Cursor and offset are mutually exclusive
      return !(data.cursor !== undefined && data.offset !== undefined);
    },
    {
      message: "Cannot use both 'cursor' and 'offset' parameters",
      path: ["cursor"],
    }
  );

/**
 * Type inference for validated query params
 */
export type RecipeListQueryInput = z.input<typeof RecipeListQuerySchema>;
export type RecipeListQueryOutput = z.output<typeof RecipeListQuerySchema>;



================================================
FILE: src/lib/services/events.service.ts
================================================
import type { SupabaseClient } from "@supabase/supabase-js";
import type { Database } from "../../db/database.types";
import type { EventType, EventDTO, CreateEventCommand } from "../../types";

/**
 * Events Service
 * Handles logging of application events to the events table
 */
export class EventsService {
  constructor(private supabase: SupabaseClient<Database>) {}

  /**
   * Create an event in the events table
   * Used by POST /api/events endpoint and internally by other endpoints
   *
   * Note: Events are for analytics only. Per RLS policy, users can insert but not read events.
   * Returns void on success to comply with RLS restrictions.
   *
   * @param userId - The user ID (from auth session)
   * @param input - Event data (type and optional payload)
   * @returns void on success
   * @throws Error if database insert fails
   */
  async createEvent(
    userId: string,
    input: CreateEventCommand
  ): Promise<void> {
    const { error } = await this.supabase
      .from("events")
      .insert({
        user_id: userId,
        type: input.type,
        payload: input.payload ?? null,
      });

    if (error) {
      console.error(`Failed to create event ${input.type} for user ${userId}:`, error);
      throw new Error(`Failed to create event: ${error.message}`);
    }
  }

  /**
   * Count events of a specific type for a user within a time window
   * Used for rate limiting
   * @param userId - The user ID
   * @param type - Event type to count
   * @param windowMinutes - Time window in minutes (default: 60)
   * @returns Number of events in the window
   */
  async countEventsInWindow(userId: string, type: EventType, windowMinutes: number = 60): Promise<number> {
    const windowStart = new Date(Date.now() - windowMinutes * 60 * 1000).toISOString();

    const { count, error } = await this.supabase
      .from("events")
      .select("*", { count: "exact", head: true })
      .eq("user_id", userId)
      .eq("type", type)
      .gte("occurred_at", windowStart);

    if (error) {
      console.error(`Failed to count events ${type} for user ${userId}:`, error);
      throw new Error(`Failed to count events: ${error.message}`);
    }

    return count ?? 0;
  }

  /**
   * Truncate prompt for logging (privacy-preserving)
   * Only stores first N characters as preview
   * @param prompt - Full prompt text
   * @param maxLength - Maximum length for preview (default: 256)
   * @returns Truncated prompt
   */
  static truncatePrompt(prompt: string, maxLength: number = 256): string {
    if (prompt.length <= maxLength) {
      return prompt;
    }
    return prompt.slice(0, maxLength) + "...";
  }
}



================================================
FILE: src/lib/services/profiles.service.ts
================================================
import type { SupabaseClient } from "@supabase/supabase-js";
import type { Database } from "../../db/database.types";
import type { CreateProfileCommand, UpdateProfileCommand, ProfileDTO } from "../../types";

/**
 * Error thrown when profile already exists (for POST operations)
 */
export class ProfileConflictError extends Error {
  constructor(message: string = "Profile already exists") {
    super(message);
    this.name = "ProfileConflictError";
  }
}

/**
 * Error thrown when profile is not found (for GET/PUT operations)
 */
export class ProfileNotFoundError extends Error {
  constructor(message: string = "Profile not found") {
    super(message);
    this.name = "ProfileNotFoundError";
  }
}

/**
 * Profiles Service
 * Handles CRUD operations for user profiles
 */
export class ProfilesService {
  constructor(private supabase: SupabaseClient<Database>) {}

  /**
   * Create a new profile for the user
   * Uses single insert operation to minimize race conditions
   * Relies on unique constraint on profiles.user_id to prevent duplicates
   *
   * @param userId - The user ID (from auth session)
   * @param command - Profile data (all fields optional)
   * @returns Created profile
   * @throws ProfileConflictError if profile already exists (23505 unique violation)
   * @throws Error for other database errors
   */
  async createProfile(userId: string, command: CreateProfileCommand): Promise<ProfileDTO> {
    const { data, error } = await this.supabase
      .from("profiles")
      .insert({
        user_id: userId,
        diet_type: command.diet_type ?? null,
        disliked_ingredients: command.disliked_ingredients ?? [],
        preferred_cuisines: command.preferred_cuisines ?? [],
      })
      .select("*")
      .single();

    // Handle unique constraint violation (profile already exists)
    if (error) {
      // PostgreSQL error code 23505 = unique_violation
      if (error.code === "23505" || error.message.includes("duplicate key")) {
        throw new ProfileConflictError("Profile already exists; use PUT /api/profile to update");
      }

      console.error(`Failed to create profile for user ${userId}:`, error);
      throw new Error(`Failed to create profile: ${error.message}`);
    }

    if (!data) {
      throw new Error("Profile created but no data returned");
    }

    return data;
  }

  /**
   * Get profile for the user
   *
   * @param userId - The user ID (from auth session)
   * @returns User's profile or null if not found
   * @throws Error for database errors
   */
  async getProfile(userId: string): Promise<ProfileDTO | null> {
    const { data, error } = await this.supabase
      .from("profiles")
      .select("*")
      .eq("user_id", userId)
      .single();

    // Profile not found is not an error - return null
    if (error && error.code === "PGRST116") {
      return null;
    }

    if (error) {
      console.error(`Failed to get profile for user ${userId}:`, error);
      throw new Error(`Failed to get profile: ${error.message}`);
    }

    return data;
  }

  /**
   * Update existing profile for the user
   * All fields in command are optional (partial update)
   *
   * @param userId - The user ID (from auth session)
   * @param command - Profile data to update (partial)
   * @returns Updated profile
   * @throws ProfileNotFoundError if profile doesn't exist
   * @throws Error for other database errors
   */
  async updateProfile(userId: string, command: UpdateProfileCommand): Promise<ProfileDTO> {
    // Build update object conditionally to support null values
    // (undefined means "don't update", null means "clear the value")
    const updateFields: any = {
      updated_at: new Date().toISOString(),
    };

    if (command.diet_type !== undefined) {
      updateFields.diet_type = command.diet_type; // can be null or DietType enum
    }
    if (command.disliked_ingredients !== undefined) {
      updateFields.disliked_ingredients = command.disliked_ingredients;
    }
    if (command.preferred_cuisines !== undefined) {
      updateFields.preferred_cuisines = command.preferred_cuisines;
    }

    const { data, error } = await this.supabase
      .from("profiles")
      .update(updateFields)
      .eq("user_id", userId)
      .select("*")
      .single();

    // Profile not found
    if (error && error.code === "PGRST116") {
      throw new ProfileNotFoundError("Profile not found; use POST /api/profile to create");
    }

    if (error) {
      console.error(`Failed to update profile for user ${userId}:`, error);
      throw new Error(`Failed to update profile: ${error.message}`);
    }

    if (!data) {
      throw new Error("Profile updated but no data returned");
    }

    return data;
  }
}



================================================
FILE: src/lib/services/recipes.service.ts
================================================
import type { SupabaseClient } from "@supabase/supabase-js";
import type { Database } from "../../db/database.types";
import type {
  RecipeDetailsDTO,
  RecipeListResponse,
  RecipeListItemDTO,
  RecipeQueryParams,
  SaveRecipeCommand,
  RecipeSummaryDTO,
  RecipeSchema,
} from "../../types";
import { decodeCursor, encodeCursor } from "../utils/cursor";
import { normalizeTags } from "../schemas/recipe.schema";

/**
 * Recipes Service
 * Handles recipe-related database operations
 */
export class RecipesService {
  constructor(private supabase: SupabaseClient<Database>) {}

  /**
   * Save a recipe to user's collection
   * Validates recipe size, checks for disliked ingredients via RPC, and returns summary
   *
   * @param userId - User ID (from auth.uid())
   * @param command - Recipe data and optional tags
   * @returns Recipe summary DTO
   * @throws Error if recipe too large (>200KB)
   * @throws Error if recipe contains disliked ingredients
   * @throws Error if database operation fails
   */
  async saveRecipe(userId: string, command: SaveRecipeCommand): Promise<RecipeSummaryDTO> {
    const { recipe, tags } = command;

    // 1. Check recipe size limit (200 KB = 204800 bytes)
    const recipeJson = JSON.stringify(recipe);
    const sizeBytes = new TextEncoder().encode(recipeJson).length;

    if (sizeBytes >= 204800) {
      throw new Error(`Recipe too large: ${sizeBytes} bytes (max 204800 bytes)`);
    }

    // 2. Normalize tags (lowercase, trim, deduplicate)
    const normalizedTags = normalizeTags(tags);

    // 3. Call RPC insert_recipe_safe to insert recipe with disliked ingredient check
    // RPC uses auth.uid() internally and respects RLS
    const { data: recipeId, error: rpcError } = await this.supabase.rpc("insert_recipe_safe", {
      p_recipe: recipe as RecipeSchema,
      p_tags: normalizedTags.length > 0 ? normalizedTags : null,
    });

    if (rpcError) {
      console.error(`Failed to save recipe for user ${userId}:`, rpcError);

      // Check if error is about disliked ingredients
      // RPC returns error message with ingredient details
      if (rpcError.message?.includes("disliked ingredient")) {
        throw new Error(`Recipe contains disliked ingredients: ${rpcError.message}`);
      }

      throw new Error(`Failed to save recipe: ${rpcError.message}`);
    }

    if (!recipeId) {
      throw new Error("RPC insert_recipe_safe returned null");
    }

    // 4. Fetch recipe summary (select only needed fields)
    const { data: summary, error: selectError } = await this.supabase
      .from("recipes")
      .select("id, user_id, title, summary, tags, created_at, updated_at")
      .eq("id", recipeId)
      .single();

    if (selectError || !summary) {
      console.error(`Failed to fetch saved recipe summary ${recipeId}:`, selectError);
      throw new Error("Failed to fetch saved recipe summary");
    }

    return summary as RecipeSummaryDTO;
  }

  /**
   * Get recipe details by ID for a specific user
   * Returns null if recipe doesn't exist or doesn't belong to the user
   *
   * @param id - Recipe UUID
   * @param userId - User ID (from auth.uid())
   * @returns Recipe details or null
   */
  async getRecipeDetails(id: string, userId: string): Promise<RecipeDetailsDTO | null> {
    const { data, error } = await this.supabase
      .from("recipes")
      .select("id, user_id, title, summary, tags, recipe, created_at, updated_at")
      .eq("id", id)
      .eq("user_id", userId)
      .single();

    if (error) {
      // Recipe not found or user doesn't have access
      if (error.code === "PGRST116") {
        // PostgreSQL error: no rows returned
        return null;
      }
      // Other database errors
      console.error(`Failed to fetch recipe ${id} for user ${userId}:`, error);
      throw new Error(`Database error: ${error.message}`);
    }

    return data as RecipeDetailsDTO;
  }

  /**
   * Delete a recipe by ID for a specific user
   * Returns true if recipe was deleted, false if not found or doesn't belong to user
   *
   * @param id - Recipe UUID
   * @param userId - User ID (from auth.uid())
   * @returns true if deleted, false if not found
   */
  async deleteRecipe(id: string, userId: string): Promise<boolean> {
    const { data, error } = await this.supabase
      .from("recipes")
      .delete()
      .eq("id", id)
      .eq("user_id", userId)
      .select("id");

    if (error) {
      console.error(`Failed to delete recipe ${id} for user ${userId}:`, error);
      throw new Error(`Database error: ${error.message}`);
    }

    return Array.isArray(data) && data.length > 0;
  }

  /**
   * List recipes for a user with filtering, search, and pagination
   *
   * @param userId - User ID (from auth.uid())
   * @param query - Query parameters (search, tags, sort, limit, cursor/offset)
   * @returns Paginated list of recipes with metadata
   */
  async listRecipes(userId: string, query: RecipeQueryParams): Promise<RecipeListResponse> {
    const { search, tags, sort = "recent", limit = 20, cursor, offset } = query;

    // Start building query
    let queryBuilder = this.supabase
      .from("recipes")
      .select("id, title, summary, tags, created_at", { count: "exact" })
      .eq("user_id", userId);

    // Apply tag filtering (OR logic with overlaps)
    if (tags && Array.isArray(tags) && tags.length > 0) {
      queryBuilder = queryBuilder.overlaps("tags", tags);
    }

    // Apply full-text search
    if (search) {
      queryBuilder = queryBuilder.textSearch("search_tsv", search, { type: "websearch" });
    }

    // Apply sorting
    const ascending = sort === "oldest";
    queryBuilder = queryBuilder.order("created_at", { ascending }).order("id", { ascending });

    // Apply cursor-based pagination
    if (cursor) {
      try {
        const { createdAt, id } = decodeCursor(cursor);

        if (sort === "recent") {
          // DESC: get records before cursor
          queryBuilder = queryBuilder.or(`created_at.lt.${createdAt},and(created_at.eq.${createdAt},id.lt.${id})`);
        } else {
          // ASC: get records after cursor
          queryBuilder = queryBuilder.or(`created_at.gt.${createdAt},and(created_at.eq.${createdAt},id.gt.${id})`);
        }
      } catch (error) {
        throw new Error(`Invalid cursor: ${error instanceof Error ? error.message : "unknown error"}`);
      }
    }

    // Fetch limit + 1 to detect if there are more results
    const fetchLimit = limit + 1;
    queryBuilder = queryBuilder.limit(fetchLimit);

    // Apply offset pagination if cursor not used
    if (offset !== undefined && !cursor) {
      queryBuilder = queryBuilder.range(offset, offset + limit);
    }

    // Execute query
    const { data, error, count } = await queryBuilder;

    if (error) {
      console.error(`Failed to list recipes for user ${userId}:`, error);
      throw new Error(`Database error: ${error.message}`);
    }

    // Calculate pagination metadata
    const items = (data || []) as RecipeListItemDTO[];
    const hasMore = items.length > limit;
    const resultItems = hasMore ? items.slice(0, limit) : items;
    const totalCount = count ?? 0;

    // Generate next cursor
    let nextCursor: string | null = null;
    if (hasMore && resultItems.length > 0) {
      const lastItem = resultItems[resultItems.length - 1];
      nextCursor = encodeCursor(lastItem.created_at, lastItem.id);
    }

    // Build response
    const response: RecipeListResponse = {
      data: resultItems,
      pagination: {
        limit,
        next_cursor: nextCursor,
        has_more: hasMore,
        total_count: totalCount,
      },
    };

    // Add message for empty results
    if (resultItems.length === 0) {
      response.message = search || tags
        ? "No recipes found matching your search criteria"
        : "You haven't saved any recipes yet";
    }

    return response;
  }
}



================================================
FILE: src/lib/services/ai/ai.service.ts
================================================
import type { RecipeSchema, ProfileDTO } from "../../../types";
import { OpenRouterProvider } from "./providers/openrouter.provider";
import { GoogleProvider } from "./providers/google.provider";
import { MockProvider } from "./providers/mock.provider";
import type { AiProvider } from "./types";
import { AiError } from "./types";

/**
 * AI Service Configuration
 */
export interface AiServiceConfig {
  provider: "openrouter" | "google" | "mock";
  apiKey?: string; // Optional for mock provider
  model?: string;
  timeout?: number;
  maxRetries?: number;
}

/**
 * AI Service
 * Facade for AI recipe generation with provider selection and retry logic
 */
export class AiService {
  private provider: AiProvider;
  private maxRetries: number;
  private retryDelay: number = 500; // Base delay in ms for exponential backoff

  constructor(config: AiServiceConfig) {
    this.maxRetries = config.maxRetries ?? 1; // Default: 1 retry as per spec

    // Initialize the appropriate provider
    switch (config.provider) {
      case "mock":
        // Mock provider doesn't need API key
        this.provider = new MockProvider({
          timeout: config.timeout,
        });
        break;
      case "openrouter":
        if (!config.apiKey) {
          throw new Error("API key is required for OpenRouter provider");
        }
        this.provider = new OpenRouterProvider({
          apiKey: config.apiKey,
          model: config.model,
          timeout: config.timeout,
        });
        break;
      case "google":
        if (!config.apiKey) {
          throw new Error("API key is required for Google provider");
        }
        this.provider = new GoogleProvider({
          apiKey: config.apiKey,
          model: config.model,
          timeout: config.timeout,
        });
        break;
      default:
        throw new Error(`Unknown AI provider: ${config.provider}`);
    }
  }

  /**
   * Generate a recipe with retry logic
   * @param prompt - User's recipe request
   * @param profile - User's profile with dietary preferences (optional)
   * @returns Generated recipe matching RecipeSchema
   */
  async generateRecipe(prompt: string, profile?: ProfileDTO): Promise<RecipeSchema> {
    let lastError: Error | undefined;
    let attempt = 0;
    const maxAttempts = this.maxRetries + 1; // Initial attempt + retries

    while (attempt < maxAttempts) {
      try {
        console.log(`AI generation attempt ${attempt + 1}/${maxAttempts}`);
        const recipe = await this.provider.generateRecipe(prompt, profile);

        // Validate size constraint (200KB limit as per DB CHECK)
        this.validateRecipeSize(recipe);

        return recipe;
      } catch (error) {
        lastError = error as Error;
        attempt++;

        // Check if error is retryable
        const isRetryable = error instanceof AiError && error.isRetryable;

        if (!isRetryable || attempt >= maxAttempts) {
          // Don't retry non-retryable errors or if we've exhausted attempts
          break;
        }

        // Calculate backoff delay with jitter
        const delay = this.calculateBackoff(attempt);
        console.log(`AI request failed (retryable), waiting ${delay}ms before retry...`);
        await this.sleep(delay);
      }
    }

    // All attempts failed
    throw lastError || new Error("AI generation failed with unknown error");
  }

  /**
   * Validate recipe size doesn't exceed 200KB limit
   * Throws error if size exceeded
   */
  private validateRecipeSize(recipe: RecipeSchema): void {
    const json = JSON.stringify(recipe);
    const sizeBytes = Buffer.byteLength(json, "utf8");
    const maxBytes = 200 * 1024; // 200KB

    if (sizeBytes > maxBytes) {
      throw new Error(
        `Generated recipe exceeds size limit: ${sizeBytes} bytes (max ${maxBytes} bytes)`
      );
    }
  }

  /**
   * Calculate exponential backoff with jitter
   */
  private calculateBackoff(attempt: number): number {
    const baseDelay = this.retryDelay;
    const exponentialDelay = baseDelay * Math.pow(2, attempt - 1);
    const jitter = Math.random() * 0.3 * exponentialDelay; // 30% jitter
    return Math.min(exponentialDelay + jitter, 5000); // Cap at 5 seconds
  }

  /**
   * Sleep utility for retry delays
   */
  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  /**
   * Factory method to create AiService from environment variables
   */
  static fromEnv(): AiService {
    const provider = import.meta.env.AI_PROVIDER as "openrouter" | "google" | "mock" | undefined;

    if (!provider) {
      throw new Error("AI_PROVIDER environment variable not set");
    }

    if (provider !== "openrouter" && provider !== "google" && provider !== "mock") {
      throw new Error(`Invalid AI_PROVIDER: ${provider}. Must be 'openrouter', 'google', or 'mock'`);
    }

    // Mock provider doesn't need API key
    if (provider === "mock") {
      return new AiService({
        provider: "mock",
        timeout: import.meta.env.AI_TIMEOUT_MS
          ? parseInt(import.meta.env.AI_TIMEOUT_MS, 10)
          : undefined,
      });
    }

    // Real providers need API keys
    const apiKey =
      provider === "openrouter"
        ? import.meta.env.OPENROUTER_API_KEY
        : import.meta.env.GOOGLE_API_KEY;

    if (!apiKey) {
      const keyName = provider === "openrouter" ? "OPENROUTER_API_KEY" : "GOOGLE_API_KEY";
      throw new Error(`${keyName} environment variable not set`);
    }

    return new AiService({
      provider,
      apiKey,
      model: import.meta.env.AI_MODEL,
      timeout: import.meta.env.AI_TIMEOUT_MS
        ? parseInt(import.meta.env.AI_TIMEOUT_MS, 10)
        : undefined,
    });
  }
}



================================================
FILE: src/lib/services/ai/types.ts
================================================
import type { RecipeSchema, ProfileDTO } from "../../../types";

/**
 * AI Provider interface
 * All AI providers must implement this interface
 */
export interface AiProvider {
  /**
   * Generate a recipe based on user prompt and profile
   * @param prompt - User's recipe request
   * @param profile - User's profile with dietary preferences (optional)
   * @returns Generated recipe matching RecipeSchema
   */
  generateRecipe(prompt: string, profile?: ProfileDTO): Promise<RecipeSchema>;
}

/**
 * AI Generation Result
 * Extended result type with optional raw response for debugging
 */
export interface AiGenerationResult {
  recipe: RecipeSchema;
  raw?: unknown; // Raw API response for server-side debugging
}

/**
 * AI Provider Configuration
 */
export interface AiProviderConfig {
  apiKey: string;
  model?: string;
  timeout?: number; // Timeout in milliseconds
  maxRetries?: number;
}

/**
 * AI Error Types
 */
export class AiError extends Error {
  constructor(
    message: string,
    public readonly isRetryable: boolean = false,
    public readonly originalError?: unknown
  ) {
    super(message);
    this.name = "AiError";
  }
}

export class AiTimeoutError extends AiError {
  constructor(message: string = "AI request timed out") {
    super(message, true);
    this.name = "AiTimeoutError";
  }
}

export class AiValidationError extends AiError {
  constructor(message: string = "AI response validation failed") {
    super(message, true); // Retryable - LLMs sometimes generate invalid JSON
    this.name = "AiValidationError";
  }
}

export class AiProviderError extends AiError {
  constructor(
    message: string,
    public readonly statusCode?: number
  ) {
    // 5xx errors are retryable, 4xx are not
    super(message, statusCode ? statusCode >= 500 : false);
    this.name = "AiProviderError";
  }
}



================================================
FILE: src/lib/services/ai/providers/google.provider.ts
================================================
import type { RecipeSchema, ProfileDTO } from "../../../../types";
import type { AiProvider, AiProviderConfig } from "../types";
import { AiProviderError, AiValidationError } from "../types";
import { RecipePromptBuilder } from "../utils/recipe-prompt-builder";
import { RecipeResponseParser } from "../utils/recipe-response-parser";
import { LLMRequestManager } from "../utils/llm-request-manager";

/**
 * Google AI Studio Provider
 * Implements the AiProvider interface using Google's Gemini API
 * Uses centralized utilities for prompt building, response parsing, and request management
 */
export class GoogleProvider implements AiProvider {
  private readonly apiKey: string;
  private readonly model: string;
  private readonly timeout: number;
  private readonly baseUrl = "https://generativelanguage.googleapis.com/v1beta";
  private readonly providerName = "Google AI";

  constructor(config: AiProviderConfig) {
    this.apiKey = config.apiKey;
    this.model = config.model || "gemini-1.5-flash"; // Default to Flash for speed/cost
    this.timeout = config.timeout || 30000; // 30 seconds default
  }

  async generateRecipe(prompt: string, profile?: ProfileDTO): Promise<RecipeSchema> {
    // Build prompts using shared utility
    const systemPrompt = RecipePromptBuilder.buildSystemPrompt(profile);
    const userPrompt = RecipePromptBuilder.buildUserPrompt(prompt);

    try {
      // Execute request with timeout handling
      const response = await LLMRequestManager.executeWithTimeout(
        (signal) =>
          fetch(`${this.baseUrl}/models/${this.model}:generateContent?key=${this.apiKey}`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              contents: [
                {
                  role: "user",
                  parts: [
                    {
                      text: `${systemPrompt}\n\n${userPrompt}`,
                    },
                  ],
                },
              ],
              generationConfig: {
                temperature: 0.7,
                maxOutputTokens: 4000,
                responseMimeType: "application/json", // Request JSON response
              },
            }),
            signal,
          }),
        this.timeout,
        this.providerName
      );

      // Handle HTTP errors
      await LLMRequestManager.handleResponseError(response, this.providerName);

      // Parse response JSON
      const data = await response.json();

      // Extract content from Google AI response format
      const content = LLMRequestManager.extractContent(
        data,
        ["candidates", "0", "content", "parts", "0", "text"],
        this.providerName
      );

      // Parse and validate recipe using shared utility
      const validated = RecipeResponseParser.parseAndValidate(content);

      return validated;
    } catch (error: unknown) {
      // Re-throw known error types
      if (
        error instanceof AiProviderError ||
        error instanceof AiValidationError ||
        (error instanceof Error && error.constructor.name === "AiTimeoutError")
      ) {
        throw error;
      }

      // Wrap unknown errors
      LLMRequestManager.handleNetworkError(error, this.providerName);
    }
  }
}



================================================
FILE: src/lib/services/ai/providers/mock.provider.ts
================================================
import type { RecipeSchema, ProfileDTO } from "../../../../types";
import type { AiProvider, AiProviderConfig } from "../types";

/**
 * Mock AI Provider for Development
 * Returns realistic fake recipes without calling external APIs
 * Useful for UI development and testing without API costs
 */
export class MockProvider implements AiProvider {
  private readonly delay: number;

  constructor(config?: Partial<AiProviderConfig>) {
    // Simulate API delay (default 1-2 seconds)
    this.delay = config?.timeout ? config.timeout / 10 : 1500;
  }

  async generateRecipe(prompt: string, profile?: ProfileDTO): Promise<RecipeSchema> {
    // Simulate network delay
    await this.sleep(this.delay + Math.random() * 500);

    // Generate mock recipe based on prompt keywords
    const recipe = this.createMockRecipe(prompt, profile);

    return recipe;
  }

  /**
   * Create a realistic mock recipe based on prompt
   */
  private createMockRecipe(prompt: string, profile?: ProfileDTO): RecipeSchema {
    const lowerPrompt = prompt.toLowerCase();

    // Detect recipe type from prompt
    let recipeType = "pasta"; // default
    let cuisine = "Italian";
    let difficulty: "easy" | "medium" | "hard" = "easy";

    if (lowerPrompt.includes("pasta")) {
      recipeType = "pasta";
      cuisine = "Italian";
    } else if (lowerPrompt.includes("curry")) {
      recipeType = "curry";
      cuisine = "Indian";
    } else if (lowerPrompt.includes("stir fry") || lowerPrompt.includes("stir-fry")) {
      recipeType = "stir-fry";
      cuisine = "Asian";
    } else if (lowerPrompt.includes("salad")) {
      recipeType = "salad";
      cuisine = "Mediterranean";
    } else if (lowerPrompt.includes("soup")) {
      recipeType = "soup";
      cuisine = "International";
    } else if (lowerPrompt.includes("burger")) {
      recipeType = "burger";
      cuisine = "American";
    } else if (lowerPrompt.includes("taco")) {
      recipeType = "taco";
      cuisine = "Mexican";
    }

    // Detect difficulty from prompt
    if (lowerPrompt.includes("quick") || lowerPrompt.includes("easy") || lowerPrompt.includes("simple")) {
      difficulty = "easy";
    } else if (lowerPrompt.includes("medium") || lowerPrompt.includes("intermediate")) {
      difficulty = "medium";
    } else if (lowerPrompt.includes("hard") || lowerPrompt.includes("complex") || lowerPrompt.includes("advanced")) {
      difficulty = "hard";
    }

    // Get recipe template
    const recipe = this.getRecipeTemplate(recipeType, cuisine, difficulty);

    // Adjust for dietary preferences
    if (profile) {
      this.adjustForDietaryPreferences(recipe, profile);
    }

    return recipe;
  }

  /**
   * Get recipe template based on type
   */
  private getRecipeTemplate(
    type: string,
    cuisine: string,
    difficulty: "easy" | "medium" | "hard"
  ): RecipeSchema {
    const templates: Record<string, RecipeSchema> = {
      pasta: {
        title: "Creamy Garlic Pasta",
        summary: "Quick and delicious pasta with a creamy garlic sauce",
        description:
          "A simple yet flavorful pasta dish featuring al dente spaghetti tossed in a rich, creamy garlic sauce with fresh herbs and parmesan cheese.",
        prep_time_minutes: 10,
        cook_time_minutes: 15,
        servings: 4,
        difficulty,
        cuisine,
        ingredients: [
          "400g spaghetti",
          "4 cloves garlic, minced",
          "200ml heavy cream",
          "50g butter",
          "100g parmesan cheese, grated",
          "Fresh parsley, chopped",
          "Salt and pepper to taste",
          "Olive oil",
        ],
        instructions: [
          "Bring a large pot of salted water to boil and cook spaghetti according to package directions",
          "While pasta cooks, melt butter in a large pan over medium heat",
          "Add minced garlic and sauté for 1-2 minutes until fragrant",
          "Pour in heavy cream and simmer for 3-4 minutes until slightly thickened",
          "Drain pasta, reserving 1 cup of pasta water",
          "Add pasta to the sauce and toss to coat, adding pasta water if needed",
          "Stir in parmesan cheese and season with salt and pepper",
          "Garnish with fresh parsley and serve immediately",
        ],
        tags: ["pasta", "italian", "quick", "comfort-food"],
        dietary_info: {
          vegetarian: true,
          vegan: false,
          gluten_free: false,
          dairy_free: false,
          nut_free: true,
        },
        nutrition: {
          calories: 520,
          protein_g: 18,
          carbs_g: 68,
          fat_g: 20,
        },
      },
      curry: {
        title: "Vegetable Chickpea Curry",
        summary: "Hearty and aromatic curry with vegetables and chickpeas",
        description:
          "A flavorful and nutritious curry packed with vegetables, chickpeas, and warming spices in a rich coconut milk sauce.",
        prep_time_minutes: 15,
        cook_time_minutes: 30,
        servings: 4,
        difficulty,
        cuisine,
        ingredients: [
          "2 cans (400g each) chickpeas, drained",
          "2 cups mixed vegetables (carrots, bell peppers, cauliflower)",
          "1 can (400ml) coconut milk",
          "1 onion, diced",
          "3 cloves garlic, minced",
          "2 tbsp curry powder",
          "1 tsp cumin",
          "1 tsp turmeric",
          "2 cups vegetable broth",
          "2 tbsp vegetable oil",
          "Fresh cilantro",
          "Salt to taste",
        ],
        instructions: [
          "Heat oil in a large pot over medium heat",
          "Add diced onion and cook until softened, about 5 minutes",
          "Add garlic, curry powder, cumin, and turmeric. Cook for 1 minute until fragrant",
          "Add mixed vegetables and stir to coat with spices",
          "Pour in coconut milk and vegetable broth. Bring to a simmer",
          "Add chickpeas and simmer for 20 minutes until vegetables are tender",
          "Season with salt to taste",
          "Garnish with fresh cilantro and serve with rice or naan",
        ],
        tags: ["curry", "indian", "vegan", "healthy", "one-pot"],
        dietary_info: {
          vegetarian: true,
          vegan: true,
          gluten_free: true,
          dairy_free: true,
          nut_free: true,
        },
        nutrition: {
          calories: 380,
          protein_g: 12,
          carbs_g: 45,
          fat_g: 18,
        },
      },
      "stir-fry": {
        title: "Quick Vegetable Stir-Fry",
        summary: "Colorful and crunchy vegetable stir-fry with savory sauce",
        description:
          "A quick and healthy stir-fry loaded with crisp vegetables in a flavorful Asian-inspired sauce.",
        prep_time_minutes: 15,
        cook_time_minutes: 10,
        servings: 4,
        difficulty,
        cuisine,
        ingredients: [
          "2 cups broccoli florets",
          "1 bell pepper, sliced",
          "1 cup snap peas",
          "2 carrots, julienned",
          "3 cloves garlic, minced",
          "1 tbsp fresh ginger, grated",
          "3 tbsp soy sauce",
          "1 tbsp sesame oil",
          "1 tbsp rice vinegar",
          "2 tsp cornstarch",
          "2 tbsp vegetable oil",
          "Sesame seeds for garnish",
        ],
        instructions: [
          "Mix soy sauce, sesame oil, rice vinegar, and cornstarch in a small bowl. Set aside",
          "Heat vegetable oil in a large wok or skillet over high heat",
          "Add garlic and ginger, stir-fry for 30 seconds",
          "Add carrots and broccoli, stir-fry for 3 minutes",
          "Add bell pepper and snap peas, stir-fry for 2 more minutes",
          "Pour in the sauce and toss everything together for 1-2 minutes until sauce thickens",
          "Remove from heat, garnish with sesame seeds",
          "Serve immediately over rice or noodles",
        ],
        tags: ["stir-fry", "asian", "quick", "healthy", "vegan"],
        dietary_info: {
          vegetarian: true,
          vegan: true,
          gluten_free: false,
          dairy_free: true,
          nut_free: true,
        },
        nutrition: {
          calories: 180,
          protein_g: 6,
          carbs_g: 22,
          fat_g: 9,
        },
      },
      salad: {
        title: "Mediterranean Quinoa Salad",
        summary: "Fresh and healthy quinoa salad with Mediterranean flavors",
        description:
          "A nutritious and colorful salad combining fluffy quinoa with fresh vegetables, olives, and a tangy lemon dressing.",
        prep_time_minutes: 15,
        cook_time_minutes: 20,
        servings: 4,
        difficulty,
        cuisine,
        ingredients: [
          "1 cup quinoa, uncooked",
          "2 cups water",
          "1 cucumber, diced",
          "2 tomatoes, diced",
          "1/2 red onion, finely chopped",
          "1/2 cup kalamata olives, halved",
          "100g feta cheese, crumbled",
          "1/4 cup fresh parsley, chopped",
          "3 tbsp olive oil",
          "2 tbsp lemon juice",
          "1 tsp dried oregano",
          "Salt and pepper to taste",
        ],
        instructions: [
          "Rinse quinoa under cold water",
          "Combine quinoa and water in a pot, bring to boil",
          "Reduce heat, cover, and simmer for 15 minutes until water is absorbed",
          "Remove from heat and let stand covered for 5 minutes, then fluff with fork",
          "Let quinoa cool to room temperature",
          "In a large bowl, combine cooled quinoa, cucumber, tomatoes, onion, and olives",
          "Whisk together olive oil, lemon juice, oregano, salt, and pepper",
          "Pour dressing over salad and toss to combine",
          "Top with feta cheese and fresh parsley before serving",
        ],
        tags: ["salad", "mediterranean", "healthy", "vegetarian", "meal-prep"],
        dietary_info: {
          vegetarian: true,
          vegan: false,
          gluten_free: true,
          dairy_free: false,
          nut_free: true,
        },
        nutrition: {
          calories: 320,
          protein_g: 10,
          carbs_g: 38,
          fat_g: 15,
        },
      },
      soup: {
        title: "Hearty Vegetable Soup",
        summary: "Comforting and nutritious vegetable soup",
        description:
          "A wholesome soup packed with seasonal vegetables in a flavorful herb-infused broth.",
        prep_time_minutes: 15,
        cook_time_minutes: 35,
        servings: 6,
        difficulty,
        cuisine,
        ingredients: [
          "2 tbsp olive oil",
          "1 onion, diced",
          "3 carrots, diced",
          "3 celery stalks, diced",
          "3 cloves garlic, minced",
          "1 can (400g) diced tomatoes",
          "6 cups vegetable broth",
          "2 potatoes, diced",
          "1 zucchini, diced",
          "1 cup green beans, chopped",
          "1 tsp dried thyme",
          "1 tsp dried basil",
          "2 bay leaves",
          "Salt and pepper to taste",
          "Fresh parsley for garnish",
        ],
        instructions: [
          "Heat olive oil in a large pot over medium heat",
          "Add onion, carrots, and celery. Cook for 5-7 minutes until softened",
          "Add garlic and cook for 1 minute until fragrant",
          "Add diced tomatoes, vegetable broth, potatoes, thyme, basil, and bay leaves",
          "Bring to a boil, then reduce heat and simmer for 15 minutes",
          "Add zucchini and green beans. Simmer for another 10-15 minutes",
          "Remove bay leaves and season with salt and pepper",
          "Garnish with fresh parsley and serve hot with crusty bread",
        ],
        tags: ["soup", "healthy", "comfort-food", "vegan", "one-pot"],
        dietary_info: {
          vegetarian: true,
          vegan: true,
          gluten_free: true,
          dairy_free: true,
          nut_free: true,
        },
        nutrition: {
          calories: 150,
          protein_g: 4,
          carbs_g: 28,
          fat_g: 5,
        },
      },
      burger: {
        title: "Classic Veggie Burger",
        summary: "Delicious plant-based burger with all the fixings",
        description:
          "A hearty vegetarian burger made with black beans and vegetables, topped with your favorite fixings.",
        prep_time_minutes: 20,
        cook_time_minutes: 15,
        servings: 4,
        difficulty,
        cuisine,
        ingredients: [
          "1 can (400g) black beans, drained and mashed",
          "1/2 cup breadcrumbs",
          "1/4 cup onion, finely chopped",
          "1 clove garlic, minced",
          "1 tsp cumin",
          "1 tsp paprika",
          "1 egg (or flax egg for vegan)",
          "Salt and pepper to taste",
          "4 burger buns",
          "Lettuce, tomato, onion for topping",
          "Your favorite condiments",
          "Vegetable oil for cooking",
        ],
        instructions: [
          "In a large bowl, mash black beans with a fork until mostly smooth",
          "Add breadcrumbs, onion, garlic, cumin, paprika, egg, salt, and pepper",
          "Mix well until combined and mixture holds together",
          "Form into 4 equal patties",
          "Heat oil in a large skillet over medium heat",
          "Cook patties for 5-6 minutes per side until crispy and heated through",
          "Toast burger buns if desired",
          "Assemble burgers with patties and your favorite toppings",
          "Serve immediately with a side of fries or salad",
        ],
        tags: ["burger", "vegetarian", "american", "comfort-food"],
        dietary_info: {
          vegetarian: true,
          vegan: false,
          gluten_free: false,
          dairy_free: true,
          nut_free: true,
        },
        nutrition: {
          calories: 320,
          protein_g: 14,
          carbs_g: 52,
          fat_g: 7,
        },
      },
      taco: {
        title: "Easy Bean Tacos",
        summary: "Quick and flavorful tacos with seasoned beans",
        description:
          "Simple and delicious tacos filled with seasoned black beans and fresh toppings.",
        prep_time_minutes: 10,
        cook_time_minutes: 15,
        servings: 4,
        difficulty,
        cuisine,
        ingredients: [
          "2 cans (400g each) black beans, drained",
          "1 tbsp olive oil",
          "1 onion, diced",
          "2 cloves garlic, minced",
          "1 tbsp chili powder",
          "1 tsp cumin",
          "1/2 tsp paprika",
          "8 small tortillas",
          "1 cup lettuce, shredded",
          "1 tomato, diced",
          "1/2 cup corn kernels",
          "1/4 cup cilantro, chopped",
          "Lime wedges",
          "Salsa and sour cream for serving",
        ],
        instructions: [
          "Heat olive oil in a pan over medium heat",
          "Add diced onion and cook until softened, about 5 minutes",
          "Add garlic, chili powder, cumin, and paprika. Cook for 1 minute",
          "Add black beans and 1/4 cup water. Simmer for 10 minutes, mashing some beans",
          "Warm tortillas in a dry skillet or microwave",
          "Fill each tortilla with seasoned beans",
          "Top with lettuce, tomato, corn, and cilantro",
          "Serve with lime wedges, salsa, and sour cream",
        ],
        tags: ["tacos", "mexican", "quick", "vegetarian", "family-friendly"],
        dietary_info: {
          vegetarian: true,
          vegan: false,
          gluten_free: false,
          dairy_free: false,
          nut_free: true,
        },
        nutrition: {
          calories: 380,
          protein_g: 16,
          carbs_g: 62,
          fat_g: 8,
        },
      },
    };

    return templates[type] || templates.pasta;
  }

  /**
   * Adjust recipe based on user's dietary preferences
   */
  private adjustForDietaryPreferences(recipe: RecipeSchema, profile: ProfileDTO): void {
    // Set dietary flags based on profile
    if (profile.diet_type === "vegan") {
      recipe.dietary_info = recipe.dietary_info || {};
      recipe.dietary_info.vegan = true;
      recipe.dietary_info.vegetarian = true;
      recipe.dietary_info.dairy_free = true;
    } else if (profile.diet_type === "vegetarian") {
      recipe.dietary_info = recipe.dietary_info || {};
      recipe.dietary_info.vegetarian = true;
    } else if (profile.diet_type === "gluten_free") {
      recipe.dietary_info = recipe.dietary_info || {};
      recipe.dietary_info.gluten_free = true;
    } else if (profile.diet_type === "dairy_free") {
      recipe.dietary_info = recipe.dietary_info || {};
      recipe.dietary_info.dairy_free = true;
    }

    // Add note about disliked ingredients if present
    if (profile.disliked_ingredients && profile.disliked_ingredients.length > 0) {
      const ingredientsNote = `\n\nNote: This recipe avoids: ${profile.disliked_ingredients.join(", ")}`;
      recipe.description = (recipe.description || "") + ingredientsNote;
    }

    // Add preferred cuisines note if present
    if (profile.preferred_cuisines && profile.preferred_cuisines.length > 0) {
      const cuisinesNote = `\n\nPreferred cuisines: ${profile.preferred_cuisines.join(", ")}`;
      recipe.description = (recipe.description || "") + cuisinesNote;
    }

    // Add diet tag
    if (profile.diet_type && !recipe.tags?.includes(profile.diet_type)) {
      recipe.tags = [...(recipe.tags || []), profile.diet_type];
    }
  }

  /**
   * Sleep utility for simulating delay
   */
  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}


================================================
FILE: src/lib/services/ai/providers/openrouter.provider.ts
================================================
import type { RecipeSchema, ProfileDTO } from "../../../../types";
import type { AiProvider, AiProviderConfig } from "../types";
import { AiProviderError, AiValidationError } from "../types";
import { RecipePromptBuilder } from "../utils/recipe-prompt-builder";
import { RecipeResponseParser } from "../utils/recipe-response-parser";
import { LLMRequestManager } from "../utils/llm-request-manager";

/**
 * OpenRouter API Provider
 * Implements the AiProvider interface using OpenRouter's API
 * Uses centralized utilities for prompt building, response parsing, and request management
 */
export class OpenRouterProvider implements AiProvider {
  private readonly apiKey: string;
  private readonly model: string;
  private readonly timeout: number;
  private readonly baseUrl = "https://openrouter.ai/api/v1";
  private readonly providerName = "OpenRouter";

  constructor(config: AiProviderConfig) {
    this.apiKey = config.apiKey;
    this.model = config.model || "anthropic/claude-3.5-sonnet";
    this.timeout = config.timeout || 30000; // 30 seconds default
  }

  async generateRecipe(prompt: string, profile?: ProfileDTO): Promise<RecipeSchema> {
    // Build prompts using shared utility
    const systemPrompt = RecipePromptBuilder.buildSystemPrompt(profile);
    const userPrompt = RecipePromptBuilder.buildUserPrompt(prompt);

    try {
      // Execute request with timeout handling
      const response = await LLMRequestManager.executeWithTimeout(
        (signal) =>
          fetch(`${this.baseUrl}/chat/completions`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${this.apiKey}`,
              "HTTP-Referer": "https://savor-ai.app", // Optional: for OpenRouter analytics
              "X-Title": "Savor AI Recipe Generator",
            },
            body: JSON.stringify({
              model: this.model,
              messages: [
                { role: "system", content: systemPrompt },
                { role: "user", content: userPrompt },
              ],
              temperature: 0.7,
              max_tokens: 4000,
            }),
            signal,
          }),
        this.timeout,
        this.providerName
      );

      // Handle HTTP errors
      await LLMRequestManager.handleResponseError(response, this.providerName);

      // Parse response JSON
      const data = await response.json();

      // Extract content from OpenRouter response format
      const content = LLMRequestManager.extractContent(
        data,
        ["choices", "0", "message", "content"],
        this.providerName
      );

      // Parse and validate recipe using shared utility
      const validated = RecipeResponseParser.parseAndValidate(content);

      return validated;
    } catch (error: unknown) {
      // Re-throw known error types
      if (
        error instanceof AiProviderError ||
        error instanceof AiValidationError ||
        (error instanceof Error && error.constructor.name === "AiTimeoutError")
      ) {
        throw error;
      }

      // Wrap unknown errors
      LLMRequestManager.handleNetworkError(error, this.providerName);
    }
  }
}



================================================
FILE: src/lib/services/ai/utils/index.ts
================================================
/**
 * AI Service Utilities
 * Centralized exports for shared LLM utilities
 */

export { RecipePromptBuilder } from "./recipe-prompt-builder";
export { RecipeResponseParser } from "./recipe-response-parser";
export { LLMRequestManager } from "./llm-request-manager";



================================================
FILE: src/lib/services/ai/utils/llm-request-manager.ts
================================================
import { AiProviderError, AiTimeoutError } from "../types";

/**
 * LLMRequestManager
 * Centralized HTTP request management with timeout and error handling
 * Provides consistent request execution across all AI providers
 */
export class LLMRequestManager {
  /**
   * Execute HTTP request with timeout handling
   * @param fetchFn - Async function that performs the fetch request
   * @param timeout - Timeout in milliseconds
   * @param providerName - Name of the provider (for error messages)
   * @returns Promise with fetch response
   * @throws AiTimeoutError if request times out
   */
  static async executeWithTimeout(
    fetchFn: (signal: AbortSignal) => Promise<Response>,
    timeout: number,
    providerName: string
  ): Promise<Response> {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    try {
      const response = await fetchFn(controller.signal);
      clearTimeout(timeoutId);
      return response;
    } catch (error) {
      clearTimeout(timeoutId);

      // Check if error is timeout
      if (error instanceof DOMException && error.name === "AbortError") {
        throw new AiTimeoutError(`${providerName} request timed out after ${timeout}ms`);
      }

      // Re-throw other errors
      throw error;
    }
  }

  /**
   * Handle HTTP response errors
   * @param response - HTTP Response object
   * @param providerName - Name of the provider (for error messages)
   * @throws AiProviderError if response is not ok
   */
  static async handleResponseError(response: Response, providerName: string): Promise<void> {
    if (!response.ok) {
      const errorText = await response.text().catch(() => "Unknown error");
      throw new AiProviderError(`${providerName} API error: ${errorText}`, response.status);
    }
  }

  /**
   * Extract content from response JSON
   * @param data - Parsed JSON response data
   * @param contentPath - Path to content in response (e.g., "choices.0.message.content")
   * @param providerName - Name of the provider (for error messages)
   * @returns Extracted content string
   * @throws AiProviderError if content is not found
   */
  static extractContent(data: any, contentPath: string[], providerName: string): string {
    let current = data;

    for (const key of contentPath) {
      if (current == null) {
        throw new AiProviderError(`No content in ${providerName} response`, undefined);
      }

      // Handle array index (e.g., "0")
      if (!isNaN(Number(key))) {
        current = current[Number(key)];
      } else {
        current = current[key];
      }
    }

    if (typeof current !== "string" || !current) {
      throw new AiProviderError(`No content in ${providerName} response`, undefined);
    }

    return current;
  }

  /**
   * Wrap network errors into AiProviderError
   * @param error - Original error
   * @param providerName - Name of the provider
   * @throws AiProviderError with formatted message
   */
  static handleNetworkError(error: unknown, providerName: string): never {
    const message = error instanceof Error ? error.message : "Unknown error";
    throw new AiProviderError(`${providerName} request failed: ${message}`, undefined);
  }
}



================================================
FILE: src/lib/services/ai/utils/recipe-prompt-builder.ts
================================================
import type { ProfileDTO } from "../../../../types";

/**
 * RecipePromptBuilder
 * Centralized prompt building logic for recipe generation
 * Used by all AI providers to ensure consistent prompt format
 */
export class RecipePromptBuilder {
  /**
   * Build system prompt with recipe schema and dietary preferences
   * @param profile - Optional user profile with dietary preferences
   * @returns Formatted system prompt
   */
  static buildSystemPrompt(profile?: ProfileDTO): string {
    let prompt = `You are a professional chef and recipe creator. Generate recipes in strict JSON format matching this structure:

{
  "title": "Recipe Title",
  "summary": "Brief one-sentence summary",
  "description": "Detailed description",
  "prep_time_minutes": 15,
  "cook_time_minutes": 30,
  "servings": 4,
  "difficulty": "easy|medium|hard",
  "cuisine": "Italian",
  "ingredients": ["ingredient 1", "ingredient 2"],
  "instructions": ["step 1", "step 2"],
  "tags": ["tag1", "tag2"],
  "dietary_info": {
    "vegetarian": true,
    "vegan": false,
    "gluten_free": false,
    "dairy_free": false,
    "nut_free": true
  },
  "nutrition": {
    "calories": 350,
    "protein_g": 12,
    "carbs_g": 45,
    "fat_g": 10
  }
}

CRITICAL RULES:
- Return ONLY valid JSON, no markdown, no explanations
- All fields must match the types shown above
- ingredients and instructions must be non-empty arrays
- times and servings must be positive numbers
- difficulty must be exactly: "easy", "medium", or "hard"`;

    // Append user dietary preferences if provided
    if (profile) {
      prompt += this.buildDietaryPreferencesSection(profile);
    }

    return prompt;
  }

  /**
   * Build user prompt from user input
   * @param userPrompt - User's recipe request
   * @returns Formatted user prompt
   */
  static buildUserPrompt(userPrompt: string): string {
    return `Create a recipe for: ${userPrompt}

Remember: Return ONLY valid JSON matching the exact structure specified in the system prompt.`;
  }

  /**
   * Build dietary preferences section for system prompt
   * @param profile - User profile with dietary preferences
   * @returns Formatted dietary preferences text
   */
  private static buildDietaryPreferencesSection(profile: ProfileDTO): string {
    let section = `\n\nUSER DIETARY PREFERENCES:`;

    if (profile.diet_type) {
      section += `\n- Diet type: ${profile.diet_type}`;
    }

    if (profile.disliked_ingredients && profile.disliked_ingredients.length > 0) {
      section += `\n- AVOID these ingredients: ${profile.disliked_ingredients.join(", ")}`;
    }

    if (profile.preferred_cuisines && profile.preferred_cuisines.length > 0) {
      section += `\n- Preferred cuisines: ${profile.preferred_cuisines.join(", ")}`;
    }

    return section;
  }
}



================================================
FILE: src/lib/services/ai/utils/recipe-response-parser.ts
================================================
import type { RecipeSchema } from "../../../../types";
import { RecipeSchemaZ } from "../../../schemas/recipe.schema";
import { AiValidationError } from "../types";

/**
 * RecipeResponseParser
 * Centralized response parsing and validation logic
 * Handles JSON extraction from markdown and schema validation
 */
export class RecipeResponseParser {
  /**
   * Parse and validate recipe JSON from AI response
   * @param content - Raw content from AI API
   * @returns Validated RecipeSchema
   * @throws AiValidationError if parsing or validation fails
   */
  static parseAndValidate(content: string): RecipeSchema {
    // Step 1: Extract JSON from markdown if needed
    const rawJson = this.extractJSON(content);

    // Step 2: Parse JSON string to object
    const parsed = this.parseJSON(rawJson);

    // Step 3: Validate against RecipeSchema
    const validated = this.validateSchema(parsed);

    return validated;
  }

  /**
   * Extract JSON from markdown code blocks if present
   * Handles formats:
   * - ```json ... ```
   * - ``` ... ```
   * - Plain JSON
   * @param content - Raw content string
   * @returns Cleaned JSON string
   */
  private static extractJSON(content: string): string {
    const cleaned = content.trim();

    // Check for markdown code blocks: ```json ... ``` or ``` ... ```
    const codeBlockMatch = cleaned.match(/```(?:json)?\s*([\s\S]*?)```/);
    if (codeBlockMatch) {
      return codeBlockMatch[1].trim();
    }

    // No code block found, return as-is
    return cleaned;
  }

  /**
   * Parse JSON string to object
   * @param jsonString - JSON string to parse
   * @returns Parsed object
   * @throws AiValidationError if JSON parsing fails
   */
  private static parseJSON(jsonString: string): unknown {
    try {
      return JSON.parse(jsonString);
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      throw new AiValidationError(`Failed to parse recipe JSON: ${message}`);
    }
  }

  /**
   * Validate parsed object against RecipeSchema using Zod
   * @param data - Parsed JSON data
   * @returns Validated RecipeSchema
   * @throws AiValidationError if schema validation fails
   */
  private static validateSchema(data: unknown): RecipeSchema {
    try {
      return RecipeSchemaZ.parse(data);
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown validation error";
      throw new AiValidationError(`Recipe schema validation failed: ${message}`);
    }
  }
}



================================================
FILE: src/lib/utils/cursor.ts
================================================
/**
 * Cursor Pagination Utilities
 * Encodes and decodes cursor tokens for keyset pagination
 */

/**
 * Cursor format: "created_at:id"
 * Encoded 
</kod_projektu>

<struktura_projektu>
Directory structure:
└── src/
    ├── env.d.ts
    ├── types.ts
    ├── components/
    │   ├── AppShell.tsx
    │   ├── Header.tsx
    │   ├── LoginThemeToggle.tsx
    │   ├── ProfileForm.tsx
    │   ├── ProfilePage.tsx
    │   ├── ProfileView.tsx
    │   ├── QueryProvider.tsx
    │   ├── Welcome.astro
    │   ├── app/
    │   │   ├── AppLayout.tsx
    │   │   ├── AppPage.tsx
    │   │   ├── DeleteButton.tsx
    │   │   ├── EmptyState.tsx
    │   │   ├── ErrorPanel.tsx
    │   │   ├── GenerateButton.tsx
    │   │   ├── GeneratorPanel.tsx
    │   │   ├── LeftPanel.tsx
    │   │   ├── PaginationLoadMore.tsx
    │   │   ├── PreviewPanel.tsx
    │   │   ├── RecipeCard.tsx
    │   │   ├── RecipeList.tsx
    │   │   ├── RecipeListSkeleton.tsx
    │   │   ├── RecipePreview.tsx
    │   │   ├── RightPanel.tsx
    │   │   ├── SaveButton.tsx
    │   │   ├── SearchBar.tsx
    │   │   ├── SortSelect.tsx
    │   │   ├── TagFilterChips.tsx
    │   │   └── TextareaWithCounter.tsx
    │   ├── auth/
    │   │   ├── AuthForm.tsx
    │   │   ├── EmailInput.tsx
    │   │   ├── ForgotPasswordForm.tsx
    │   │   ├── PasswordInput.tsx
    │   │   ├── ResetPasswordForm.tsx
    │   │   └── UserMenu.tsx
    │   ├── profile/
    │   │   ├── DietTypeSelect.tsx
    │   │   └── TagsInput.tsx
    │   ├── theme/
    │   │   ├── DarkModeToggle.tsx
    │   │   └── ThemeProvider.tsx
    │   └── ui/
    │       ├── alert-dialog.tsx
    │       ├── alert.tsx
    │       ├── badge.tsx
    │       ├── button.tsx
    │       ├── card.tsx
    │       ├── dropdown-menu.tsx
    │       ├── input.tsx
    │       ├── label.tsx
    │       ├── select.tsx
    │       ├── skeleton.tsx
    │       ├── sonner.tsx
    │       ├── tabs.tsx
    │       ├── textarea.tsx
    │       └── tooltip.tsx
    ├── db/
    │   ├── database.types.ts
    │   └── supabase.client.ts
    ├── layouts/
    │   └── Layout.astro
    ├── lib/
    │   ├── utils.ts
    │   ├── api/
    │   │   ├── http.ts
    │   │   ├── profile.ts
    │   │   └── recipes.ts
    │   ├── auth/
    │   │   ├── api.ts
    │   │   ├── telemetry.ts
    │   │   ├── types.ts
    │   │   ├── useAuth.ts
    │   │   └── validation.ts
    │   ├── hooks/
    │   │   ├── useScrollRestoration.ts
    │   │   └── useUrlFilters.ts
    │   ├── mappers/
    │   │   └── profile.ts
    │   ├── schemas/
    │   │   ├── common.schema.ts
    │   │   ├── events.schema.ts
    │   │   ├── profile.schema.ts
    │   │   ├── recipe.schema.ts
    │   │   └── recipes.schema.ts
    │   ├── services/
    │   │   ├── events.service.ts
    │   │   ├── profiles.service.ts
    │   │   ├── recipes.service.ts
    │   │   └── ai/
    │   │       ├── ai.service.ts
    │   │       ├── types.ts
    │   │       ├── providers/
    │   │       │   ├── google.provider.ts
    │   │       │   ├── mock.provider.ts
    │   │       │   └── openrouter.provider.ts
    │   │       └── utils/
    │   │           ├── index.ts
    │   │           ├── llm-request-manager.ts
    │   │           ├── recipe-prompt-builder.ts
    │   │           └── recipe-response-parser.ts
    │   └── utils/
    │       └── cursor.ts
    ├── middleware/
    │   └── index.ts
    ├── pages/
    │   ├── app.astro
    │   ├── index.astro
    │   ├── login.astro
    │   ├── profile.astro
    │   ├── api/
    │   │   ├── events.ts
    │   │   ├── auth/
    │   │   │   ├── login.ts
    │   │   │   ├── logout.ts
    │   │   │   └── register.ts
    │   │   ├── profile/
    │   │   │   └── index.ts
    │   │   └── recipes/
    │   │       ├── [id].ts
    │   │       ├── generate.ts
    │   │       └── index.ts
    │   ├── app/
    │   │   └── recipes/
    │   │       └── [id].astro
    │   └── auth/
    │       ├── forgot.astro
    │       └── reset.astro
    └── styles/
        └── global.css
</struktura_projektu>

<stos_technologiczny>
[tech-stack.md](mdc:.ai/tech-stack.md)
</stos_technologiczny>

Twoim zadaniem jest wygenerowanie szczegółowego planu testów, który będzie dostosowany do specyfiki projektu, uwzględniając wykorzystywane technologie, strukturę kodu oraz kluczowe elementy repozytorium. Plan testów powinien być napisany w języku polskim.

Przed stworzeniem planu testów, przeprowadź dogłębną analizę projektu wewnątrz bloku <analiza_projektu> w swoim bloku myślowym. W analizie uwzględnij:

1. Kluczowe komponenty projektu wynikające z analizy kodu:
   - Wymień i opisz główne komponenty projektu
2. Specyfikę stosu technologicznego i jego wpływ na strategię testowania:
   - Przeanalizuj każdy element stosu technologicznego i jego implikacje dla testowania
3. Priorytety testowe bazujące na strukturze repozytorium:
   - Zidentyfikuj i uszereguj obszary testowe według ważności
4. Potencjalne obszary ryzyka wymagające szczególnej uwagi w testach:
   - Wymień potencjalne ryzyka i uzasadnij, dlaczego wymagają specjalnej uwagi

Po zakończeniu analizy, stwórz plan testów wewnątrz bloku <plan_testów>. Plan powinien zawierać:

1. Wprowadzenie i cele testowania
2. Zakres testów
3. Typy testów do przeprowadzenia (np. testy jednostkowe, integracyjne, wydajnościowe)
4. Scenariusze testowe dla kluczowych funkcjonalności
5. Środowisko testowe
6. Narzędzia do testowania
7. Harmonogram testów
8. Kryteria akceptacji testów
9. Role i odpowiedzialności w procesie testowania
10. Procedury raportowania błędów

Pamiętaj, aby plan testów był:
- Dokładnie dostosowany do kontekstu projektu
- Uwzględniał specyfikę wykorzystywanych technologii
- Priorytetyzował kluczowe elementy repozytorium
- Był napisany w języku polskim
- Prezentował wysoką jakość i profesjonalizm

Rozpocznij od analizy, a następnie przejdź do tworzenia planu testów. Twój końcowy wynik powinien składać się tylko z planu testów i nie powinien powielać ani streszczać żadnej pracy wykonanej w bloku analizy projektu.

Zapisz ten plan w formacie Markdown w pliku .ai/test-plan.md.