-- ============================================================================
-- Migration: Initial Schema for SavorAI MVP
-- ============================================================================
-- Description: Creates the complete database schema including:
--   - Extension setup (unaccent for FTS)
--   - Helper functions (normalize_text, update_updated_at)
--   - Application tables (profiles, recipes, events)
--   - Indexes for performance optimization
--   - Full-text search triggers
--   - Row Level Security (RLS) policies
--   - RPC functions for safe recipe insertion and event export
--
-- Tables affected: profiles, recipes, events
-- Dependencies: auth.users (managed by Supabase Auth)
--
-- Notes:
--   - All foreign keys reference auth.users(id) with CASCADE delete
--   - RLS is enabled on all tables with granular policies per operation
--   - FTS uses 'simple' dictionary with unaccent for multilingual support
--   - UUID primary keys are used for recipes and events (security best practice)
-- ============================================================================

-- ============================================================================
-- SECTION 1: Extensions and Helper Functions
-- ============================================================================

-- Enable unaccent extension for text normalization (removes diacritics)
-- This allows searching for "krevetki" to match "krewetki" (Polish characters)
create extension if not exists unaccent;

-- Normalize text by removing accents and converting to lowercase
-- Used in FTS and array normalization for consistent searching and validation
create or replace function normalize_text(text)
returns text as $$
  select lower(unaccent($1));
$$ language sql immutable;

-- Auto-update the updated_at column on row modification
-- Ensures accurate tracking of last modification timestamp
create or replace function update_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- ============================================================================
-- SECTION 2: Application Tables
-- ============================================================================

-- ----------------------------------------------------------------------------
-- Table: profiles
-- ----------------------------------------------------------------------------
-- Stores user dietary preferences and settings (1:1 with auth.users)
-- Includes: diet type, disliked ingredients, preferred cuisines, dark mode
create table profiles (
  -- Primary key: references auth.users for 1:1 relationship
  user_id uuid primary key references auth.users(id) on delete cascade,

  -- Diet type constraint: nullable to allow users without specific diet
  -- CHECK constraint for flexibility (easier to extend than ENUM)
  diet_type text null check (
    diet_type in (
      'vegan',
      'vegetarian',
      'pescatarian',
      'keto',
      'paleo',
      'gluten_free',
      'dairy_free',
      'low_carb',
      'mediterranean',
      'omnivore'
    )
  ),

  -- Arrays of disliked ingredients and preferred cuisines
  -- Will be normalized to lowercase by trigger for consistent matching
  disliked_ingredients text[] null default '{}',
  preferred_cuisines text[] null default '{}',

  -- Audit timestamps
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- Enable RLS on profiles table
-- Users can only access their own profile data
alter table profiles enable row level security;

-- ----------------------------------------------------------------------------
-- Table: recipes
-- ----------------------------------------------------------------------------
-- Stores user-generated recipes in JSONB format (schema_v1)
-- Includes derived columns for efficient querying and full-text search
create table recipes (
  -- UUID primary key: better security than BIGSERIAL (no enumeration attack)
  id uuid primary key default gen_random_uuid(),

  -- Owner reference: each recipe belongs to one user
  user_id uuid not null references auth.users(id) on delete cascade,

  -- Source of truth: full recipe in JSONB format (schema_v1)
  -- Size limit: ~200KB to prevent abuse
  recipe jsonb not null check (octet_length(recipe::text) < 204800),

  -- Tags for filtering (OR logic): normalized to lowercase by trigger
  tags text[] null default '{}',

  -- Derived columns: extracted from recipe JSONB by trigger
  -- These enable fast queries without JSON parsing
  title text not null,
  summary text null,
  ingredients_text text[] null,

  -- Full-text search vector: auto-generated by trigger
  -- Uses weighted search: title (A), summary (B), ingredients (C)
  search_tsv tsvector null,

  -- Audit timestamps
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- Enable RLS on recipes table
-- Users can only access their own recipes
alter table recipes enable row level security;

-- ----------------------------------------------------------------------------
-- Table: events
-- ----------------------------------------------------------------------------
-- Stores analytics events for KPI tracking (session, profile, AI, recipe)
-- Read access restricted to service_role for privacy
create table events (
  -- UUID primary key for event identification
  id uuid primary key default gen_random_uuid(),

  -- User who triggered the event
  user_id uuid not null references auth.users(id) on delete cascade,

  -- Event type constraint: only allowed event types from PRD
  type text not null check (
    type in (
      'session_start',
      'profile_edited',
      'ai_prompt_sent',
      'ai_recipe_generated',
      'recipe_saved'
    )
  ),

  -- Optional event context (e.g., AI prompt, error details)
  payload jsonb null,

  -- Event timestamp: no updated_at since events are immutable
  occurred_at timestamptz not null default now()
);

-- Enable RLS on events table
-- Users can only insert their own events; reading restricted to service_role
alter table events enable row level security;

-- ============================================================================
-- SECTION 3: Indexes for Performance Optimization
-- ============================================================================

-- ----------------------------------------------------------------------------
-- Indexes for profiles table
-- ----------------------------------------------------------------------------
-- GIN indexes for array containment queries (optional, for future features)
-- Allows efficient filtering by dietary preferences
create index if not exists idx_profiles_disliked_ingredients on profiles using gin(disliked_ingredients);
create index if not exists idx_profiles_preferred_cuisines on profiles using gin(preferred_cuisines);

-- ----------------------------------------------------------------------------
-- Indexes for recipes table
-- ----------------------------------------------------------------------------
-- Composite index for keyset pagination: (user_id, created_at DESC, id)
-- Supports efficient "recently added" sorting without OFFSET
-- Single index scan for user filtering + sorting + pagination
create index idx_recipes_user_created on recipes(user_id, created_at desc, id);

-- GIN index for tag filtering (OR logic)
-- Allows efficient queries like: WHERE tags && ARRAY['seafood', 'quick']
create index idx_recipes_tags on recipes using gin(tags);

-- GIN index for full-text search
-- Enables fast search queries on title, summary, and ingredients
create index idx_recipes_search_tsv on recipes using gin(search_tsv);

-- ----------------------------------------------------------------------------
-- Indexes for events table
-- ----------------------------------------------------------------------------
-- Composite index for user event history: (user_id, occurred_at DESC)
-- Supports efficient queries for user activity timeline
create index idx_events_user_occurred on events(user_id, occurred_at desc);

-- Composite index for event type analysis: (type, occurred_at DESC)
-- Supports efficient KPI queries (e.g., count ai_recipe_generated per week)
create index idx_events_type_occurred on events(type, occurred_at desc);

-- ============================================================================
-- SECTION 4: Triggers for Data Normalization and FTS
-- ============================================================================

-- ----------------------------------------------------------------------------
-- Trigger: Normalize profile arrays
-- ----------------------------------------------------------------------------
-- Automatically normalizes disliked_ingredients and preferred_cuisines
-- to lowercase with unaccent for consistent matching
create or replace function normalize_profile_arrays()
returns trigger as $$
begin
  -- Normalize disliked_ingredients array
  if new.disliked_ingredients is not null then
    new.disliked_ingredients := array(
      select normalize_text(elem) from unnest(new.disliked_ingredients) as elem
    );
  end if;

  -- Normalize preferred_cuisines array
  if new.preferred_cuisines is not null then
    new.preferred_cuisines := array(
      select normalize_text(elem) from unnest(new.preferred_cuisines) as elem
    );
  end if;

  return new;
end;
$$ language plpgsql;

-- Apply normalization trigger before insert or update
create trigger trigger_normalize_profile_arrays
before insert or update on profiles
for each row
execute function normalize_profile_arrays();

-- ----------------------------------------------------------------------------
-- Trigger: Update derived columns and search vector in recipes
-- ----------------------------------------------------------------------------
-- Extracts title, summary, ingredients_text from recipe JSONB
-- Generates full-text search vector with weighted terms
create or replace function update_recipes_derived_columns()
returns trigger as $$
begin
  -- Extract title and summary from recipe JSONB
  new.title := coalesce(new.recipe->>'title', '');
  new.summary := coalesce(new.recipe->>'summary', new.recipe->>'description', '');

  -- Extract ingredients as text array
  new.ingredients_text := array(
    select jsonb_array_elements_text(new.recipe->'ingredients')
  );

  -- Generate full-text search vector with weighted terms:
  -- A (title) > B (summary) > C (ingredients)
  -- Uses 'simple' dictionary with normalize_text for multilingual support
  new.search_tsv :=
    setweight(to_tsvector('simple', normalize_text(new.title)), 'A') ||
    setweight(to_tsvector('simple', normalize_text(coalesce(new.summary, ''))), 'B') ||
    setweight(to_tsvector('simple', normalize_text(array_to_string(new.ingredients_text, ' '))), 'C');

  return new;
end;
$$ language plpgsql;

-- Apply derived columns trigger before insert or update
create trigger trigger_update_recipes_derived_columns
before insert or update on recipes
for each row
execute function update_recipes_derived_columns();

-- ----------------------------------------------------------------------------
-- Trigger: Auto-update updated_at timestamp
-- ----------------------------------------------------------------------------
-- Automatically updates the updated_at column on profile modification
create trigger trigger_profiles_updated_at
before update on profiles
for each row
execute function update_updated_at();

-- Automatically updates the updated_at column on recipe modification
-- Note: Recipe updates are blocked by RLS in MVP, but trigger is ready
create trigger trigger_recipes_updated_at
before update on recipes
for each row
execute function update_updated_at();

-- ============================================================================
-- SECTION 5: Row Level Security (RLS) Policies
-- ============================================================================

-- ----------------------------------------------------------------------------
-- RLS Policies for profiles table
-- ----------------------------------------------------------------------------
-- Policy: Users can view only their own profile
-- Rationale: Profile data is private and user-specific
create policy "Users can view their own profile"
on profiles for select
using (auth.uid() = user_id);

-- Policy: Users can create only their own profile
-- Rationale: Prevents users from creating profiles for other users
create policy "Users can create their own profile"
on profiles for insert
with check (auth.uid() = user_id);

-- Policy: Users can update only their own profile
-- Rationale: Users should only modify their own preferences
create policy "Users can update their own profile"
on profiles for update
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

-- Policy: Users can delete only their own profile
-- Rationale: Users can remove their profile data (GDPR compliance)
create policy "Users can delete their own profile"
on profiles for delete
using (auth.uid() = user_id);

-- ----------------------------------------------------------------------------
-- RLS Policies for recipes table
-- ----------------------------------------------------------------------------
-- Policy: Users can view only their own recipes
-- Rationale: Recipes are private to each user (no sharing in MVP)
create policy "Users can view their own recipes"
on recipes for select
using (auth.uid() = user_id);

-- Policy: Users can create recipes only in their own collection
-- Rationale: Prevents users from adding recipes to other users' collections
create policy "Users can create their own recipes"
on recipes for insert
with check (auth.uid() = user_id);

-- Policy: Users can delete only their own recipes
-- Rationale: Users can remove recipes from their collection (hard delete)
create policy "Users can delete their own recipes"
on recipes for delete
using (auth.uid() = user_id);

-- NOTE: No UPDATE policy for recipes table
-- Rationale: Per PRD requirement (US-009), saved recipes are read-only
-- This enforces the "no editing after save" rule at the database level

-- ----------------------------------------------------------------------------
-- RLS Policies for events table
-- ----------------------------------------------------------------------------
-- Policy: Users can create only their own events
-- Rationale: Prevents users from logging events for other users
create policy "Users can create their own events"
on events for insert
with check (auth.uid() = user_id);

-- NOTE: No SELECT, UPDATE, DELETE policies for events table
-- Rationale: Event data is for analytics only, accessible via service_role
-- This ensures user privacy and prevents tampering with analytics data

-- ============================================================================
-- SECTION 6: RPC Functions for Business Logic
-- ============================================================================

-- ----------------------------------------------------------------------------
-- Function: insert_recipe_safe
-- ----------------------------------------------------------------------------
-- Safely inserts a recipe with automatic "disliked ingredients" validation
-- Implements PRD requirement US-007: Block saving recipes with disliked items
--
-- Parameters:
--   p_recipe: Recipe JSONB (schema_v1 format)
--   p_tags: Optional array of tags (default empty)
--
-- Returns: UUID of the inserted recipe
--
-- Throws exception if:
--   - User is not authenticated
--   - Recipe contains any disliked ingredient (case-insensitive, substring match)
--
-- Side effects:
--   - Logs 'recipe_saved' event to events table
create or replace function insert_recipe_safe(
  p_recipe jsonb,
  p_tags text[] default '{}'
)
returns uuid as $$
declare
  v_user_id uuid;
  v_disliked text[];
  v_ingredients text[];
  v_recipe_id uuid;
  v_ingredient text;
  v_disliked_item text;
begin
  -- Get authenticated user ID from Supabase auth context
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Unauthorized';
  end if;

  -- Fetch user's disliked ingredients list
  select disliked_ingredients into v_disliked
  from profiles
  where user_id = v_user_id;

  -- Default to empty array if user has no profile or no dislikes
  if v_disliked is null then
    v_disliked := '{}';
  end if;

  -- Extract ingredients from recipe JSONB and normalize
  v_ingredients := array(
    select normalize_text(jsonb_array_elements_text(p_recipe->'ingredients'))
  );

  -- Validate: check for disliked ingredient collision
  -- Uses case-insensitive substring matching (LIKE %item%)
  foreach v_ingredient in array v_ingredients loop
    foreach v_disliked_item in array v_disliked loop
      if v_ingredient like '%' || v_disliked_item || '%' then
        raise exception 'Recipe contains disliked ingredient: %', v_disliked_item;
      end if;
    end loop;
  end loop;

  -- Insert recipe (triggers will populate derived columns)
  insert into recipes (user_id, recipe, tags)
  values (v_user_id, p_recipe, p_tags)
  returning id into v_recipe_id;

  -- Log recipe_saved event for KPI tracking
  insert into events (user_id, type, payload)
  values (v_user_id, 'recipe_saved', jsonb_build_object('recipe_id', v_recipe_id));

  return v_recipe_id;
end;
$$ language plpgsql security definer;

-- ----------------------------------------------------------------------------
-- Function: export_events_ndjson
-- ----------------------------------------------------------------------------
-- Exports events in NDJSON format for analytics and KPI calculation
-- Restricted to service_role only for security and privacy
--
-- Parameters:
--   p_from_date: Optional start date filter (default: all time)
--   p_to_date: Optional end date filter (default: now)
--
-- Returns: Table of JSONB objects (one per event)
--
-- Usage example (with service_role key):
--   SELECT * FROM export_events_ndjson('2025-01-01'::timestamptz, '2025-01-31'::timestamptz);
create or replace function export_events_ndjson(
  p_from_date timestamptz default null,
  p_to_date timestamptz default null
)
returns table (event_json jsonb) as $$
begin
  -- Security check: only service_role can export events
  -- This prevents users from accessing analytics data
  if current_setting('request.jwt.claim.role', true) != 'service_role' then
    raise exception 'Access denied: service_role required';
  end if;

  -- Return events within the specified date range
  return query
  select to_jsonb(e.*) as event_json
  from events e
  where (p_from_date is null or e.occurred_at >= p_from_date)
    and (p_to_date is null or e.occurred_at <= p_to_date)
  order by e.occurred_at;
end;
$$ language plpgsql security definer;

-- ============================================================================
-- END OF MIGRATION
-- ============================================================================
-- Next steps:
--   1. Run migration: supabase db push
--   2. Verify tables: supabase db inspect
--   3. Test RLS policies with authenticated user tokens
--   4. Implement application layer validation for recipe schema_v1
-- ============================================================================